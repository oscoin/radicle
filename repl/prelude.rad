
(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
        (print! (string-append "Test '" name "' failed")))))

;; empty?
(define empty? (lambda (ls) (eq? ls (list))))
(should-be "empty" (empty? (list 2)) #f)

;; boolean functions

(define not (lambda (x) (if x #f #t)))

(define and
  (lambda (x y)
    (if x y x)))

(should-be "and" (and #t #t) #t)
(should-be "and" (and #t #f) #f)
(should-be "and" (and #f #t) #f)
(should-be "and" (and #f #f) #f)

(define or
  (lambda (x y)
    (if x x y)))

(should-be "or" (or #t #t) #t)
(should-be "or" (or #t #f) #t)
(should-be "or" (or #f #t) #t)
(should-be "or" (or #f #f) #f)

(define all
  (lambda (xs) (foldr and #t xs)))

(should-be "all" (all '()) #t)
(should-be "all" (all '(#t)) #t)
(should-be "all" (all '(#f)) #f)
(should-be "all" (all '(#t #t #t #t)) #t)
(should-be "all" (all '(#t #t #f #t)) #f)

(define some
  (lambda (xs) (foldr or #f xs)))

(should-be "some" (some '()) #f)
(should-be "some" (some '(#t)) #t)
(should-be "some" (some '(#f)) #f)
(should-be "some" (some '(#f #f #f)) #f)
(should-be "some" (some '(#t #t #t #t)) #t)
(should-be "some" (some '(#t #t #f #t)) #t)

;; y-combinators

(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

;; List functions

(define length
  (lambda (xs)
    (foldr (lambda (x acc) (+ acc 1)) 0 xs)))

;; reverse
(define reverse (lambda (ls)
  (define go (Y2 (lambda (go)
    (lambda (acc new)
      (if (empty? new)
          acc
          (go (cons (head new) acc) (tail new)))))))
  (go (list) ls)))

(should-be "reverse" (reverse (list 1 2 3)) (list 3 2 1))

;; range
(define range (Y2 (lambda (range) (lambda (from to)
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(should-be "range" (range 1 5) (list 1 2 3 4 5))

;; filter
(define filter (Y2 (lambda (filter) (lambda (pred ls)
  (if (empty? ls)
      ls
  (if (pred (head ls))
      (cons (head ls) (filter pred (tail ls)))
      (filter pred (tail ls))))))))

(should-be "filter"
  (filter (lambda (x) (< x 10)) (list 3 10 11))
  (list 3))

;; dict functions

(define dict-from-list
  (lambda (xs)
    (foldr (lambda (kv acc) (insert (head kv) (head (tail kv)) acc)) (dict) xs)))

(should-be "dict-from-list"
           (dict-from-list '('(:one 1) '(:two 2)))
           (dict :one 1 :two 2))

(define keys
  (lambda (d)
    (map head (seq d))))

;; Uncomment this test once map is fixed.
;; (should-be "keys"
;;            (keys (dict :one 1 :two 2))
;;            '(:one :two))

;; modify-ref
(define modify-ref
  (lambda (r fn)
    (write-ref r (fn (read-ref r)))))

;; modify-map
(define modify-map (lambda (key fn mp)
  (insert key (fn (lookup key mp)) mp)))

(should-be "modify-map"
  (modify-map 'a (lambda (x) (+ x 1)) (dict 'a 5))
  (dict 'a 6))

;; Lenses

;; Makes a lens out of a getter and a setter.
(define make-lens
  (lambda (g s)
    (dict 'getter g 'setter s)))

;; View a value through a lens.
(define view
  (lambda (lens target)
    ((lookup 'getter lens) target)))

;; Set a value though a lens.
(define set
  (lambda (lens new-view target)
    ((lookup 'setter lens) new-view target)))

;; Compose lenses
(define ..
  (lambda (lens1 lens2)
    (make-lens
     (lambda (target) (view lens2 (view lens1 target)))
     (lambda (new-view target) (set lens1 (set lens2 new-view (view lens1 target)) target)))))

;; Modify a value through a lens.
(define over
  (lambda (lens f target)
    (set lens (f (view lens target)) target)))

;; A lens targetting keys of dicts.
(define key
  (lambda (k)
    (make-lens (lambda (mp) (lookup k mp))
               (lambda (v mp) (insert k v mp)))))

(should-be "view lens"
           (view (key :one) (dict :one 1 :two 2))
           1)

(should-be "set lens"
           (set (key :two) 42 (dict :one 1 :two 2))
           (dict :one 1 :two 42))

(should-be "over lens"
           (over (key :one) (lambda (x) (+ x 1)) (dict :one 1 :two 2))
           (dict :one 2 :two 2))

(should-be "lens composition"
           (over (.. (key :a) (key :b))
                 (lambda (x) (+ x 1))
                 (dict :a (dict :b 2)))
           (dict :a (dict :b 3)))

;; Voting stuff. Should be moved elsewhere when we have an import mechanism.

;; Initial state of the vote
;; (define state
;;   (ref
;;    (dict
;;     'voters '("Alice" "Bob" "Charlie" "Dan")
;;     'votes (dict))))

;; Takes a state and a vote and returns a new state, or throws and error if the
;; voting expression is invalid.
;; (define ev-vote
;;   (lambda (s expr)
;;     (if (eq? (head expr) 'vote)
;;         (if (and (string? (head (tail expr)))
;;                  (boolean? (head (tail (tail expr)))))
;;             (if (member? (head (tail expr)) (view (key 'voters) (read-ref state)))
;;                 (set (.. (key 'votes) (key (head (tail expr))))
;;                      (head (tail (tail expr)))
;;                      s)
;;                 (throw 'invalid-input "You do not have permission to vote."))
;;             (throw 'invalid-input "A vote must be a name and a bool."))
;;         (throw 'invalid-input "All you can do is vote."))
;;     ))

;; Returns an eval which operates a state machine.
(define state-machine-eval
  (lambda (init-state transition)
    (define state (ref init-state))
    (lambda (e)
      (print! e)
      (cond
       (not (list? e))          (throw 'invalid-input "Input must be a compound expression.")
       (not (eq? (length e) 2)) (throw 'invalid-input "Input must be a verb and an input expression.")
       :else
       (do (define verb (head e))
           (define input (head (tail e)))
           (cond
            (eq? verb 'input) (do
                                (define new-state (transition (read-ref state) input))
                                (write-ref state new-state)
                                (print! (string-append "ACCEPTED! new state: " new-state))
                                )
            (eq? verb 'new-trans-func) (throw 'not-impl-yet "yo")
            :else (throw 'invalid-input "Only verbs supported are 'input' and 'new-trans-func'.")))))))

(define inc (lambda (e) (+ x 1)))

;; (do (define eval-ref (ref eval)) (define eval (lambda (e) ((read-ref eval-ref) e))) (write-ref eval-ref (state-machine-eval 0 +)))

(define voting-ended?
  (lambda (s)
    (define votes (dict-from-list (map reverse (seq (view (key 'votes) s)))))
    votes
    ))

(define boom
  (quote
    (define eval ev-vote)))



;; Account stuff. Should be moved elsewhere when we have an import mechanism

(define create-currency (lambda ()

  ;; The map of all accounts
  (define accounts (ref (dict)))

  ;; Create an account with 10 coins.
  (define new-account (lambda (name)
    (modify-ref accounts (lambda (acc)
      (insert name 10 acc)))))

  ;; Get an account's balance
  (define account-balance (lambda (name)
    (lookup name (read-ref accounts))))

  ;; Transfer money
  (define transfer (lambda (from to amount)
    (define acc (read-ref accounts))
    (write-ref accounts (if (> amount (lookup from acc))
            (print! "not enough balance")
            (modify-map
              to
              (lambda (x) (+ x amount))
              (modify-map from (lambda (x) (- x amount)) acc))))))

  (define dispatch (lambda (m)
    (if (eq? m 'new-account) new-account
    (if (eq? m 'account-balance) account-balance
    (if (eq? m 'transfer) transfer
        (print! "error: currency- unknown message"))))))
  dispatch))

(define currency (create-currency))


(define new-eval (lambda (expr)
  (if (eq? (head expr) 'new-account)
      ((currency 'new-account) (head (tail expr)))
  (if (eq? (head expr) 'account-balance)
      ((currency 'account-balance) (head (tail expr)))
  (if (eq? (head expr) 'transfer)
      ((currency 'transfer) (head (tail expr)) (head (tail (tail expr))) (head
          (tail
                      (tail (tail expr)))))
  (print! "transaction must be new-account, transfer, or account-balance"))))))


;; The Repl

(define repl
  (dict
     'name "repl"
     ;; Parse errors are thrown here
     'getter (lambda () (catch 'parse-error (get-line!) print!))))

(catch 'any
    (subscribe-to! repl print!)
    (lambda (x) (print! x) (subscribe-to! repl print!)))
