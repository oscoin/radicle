(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
        (print! (string-append "Test '" name "' failed")))))

;; empty?
(define empty? (lambda (ls) (eq? ls (list))))
(should-be "empty" (empty? (list 2)) #f)

;; not
(define not (lambda (x) (if x #f #t)))
(should-be "not" (not #t) #f)

;; y-combinator
(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))
(define Y3
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2 arg3) ((g g) arg1 arg2 arg3)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

;; length
(define length (lambda (ls)
  (if (list? ls)
      (foldr (lambda (x y) (+ y 1)) 0 ls)
      (throw 'type-error "length: expecting list"))))
(should-be "length" (length (list 0 1 2)) 3)


;; reverse
(define reverse (lambda (ls)
  (define go (Y2 (lambda (go)
    (lambda (acc new)
      (if (empty? new)
          acc
          (go (cons (head new) acc) (tail new)))))))
  (go (list) ls)))

(should-be "reverse" (reverse (list 1 2 3)) (list 3 2 1))

;; range
(define range (Y2 (lambda (range) (lambda (from to)
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(should-be "range" (range 1 5) (list 1 2 3 4 5))

;; filter
(define filter (Y2 (lambda (filter) (lambda (cond ls)
  (if (empty? ls)
      ls
  (if (cond (head ls))
      (cons (head ls) (filter cond (tail ls)))
      (filter cond (tail ls))))))))

(should-be "filter"
  (filter (lambda (x) (< x 10)) (list 3 10 11))
  (list 3))

;; modify-ref
(define modify-ref (lambda (ref fn)
  (write-ref ref (fn (read-ref ref)))))

;; modify-map
(define modify-map (lambda (key fn mp)
  (insert key (fn (lookup key mp)) mp)))

(should-be "modify-map"
  (modify-map 'a (lambda (x) (+ x 1)) (dict a 5))
  (dict a 6))

;; recursively
(define recursively (Y3 (lambda (recursively) (lambda (rec-cond fn e)
  (if (rec-cond e)
      (map (lambda (x) (recursively rec-cond fn x)) e)
      (fn e))))))

(should-be "recursively"
  (recursively list? (lambda (x) (+ x 1)) '(0 1 '(2 3)))
  '(1 2 (3 4)))

;; macro

(define macro (lambda (name def) (lambda (exp)
  (recursively
    (lambda (expr)
      (and (list? expr) (> (length expr) 0) (not (eq? (head expr)) name)))
    (lambda (expr) expr)
    ;; (lambda (expr)
    ;;   (if (eq? (head expr) name)
    ;;       (apply def (tail expr))
    ;;       (eval expr)))
    exp))))

;; ;; cond
;; (define eval (macro 'cond ((lambda ()
;;   (define go (Y (lambda (go) (lambda (ls)
;;     (if (empty? ls)
;;         (list)
;;         (if (eval (head (head ls)))
;;             (nth 1 (head ls))
;;             (go (tail ls))))))))
;;
;;   go))))

;; (should-be "cond (empty)"
;;   (cond (list))
;;   (list))
;;
;; (should-be "cond"
;;   (cond
;;     '((#f 0)
;;      (#f 1)
;;      (#t 2)))
;;   2)

;; Account stuff. Should be moved elsewhere when we have an import mechanism

(define create-currency (lambda ()

  ;; The map of all accounts
  (define accounts (ref (dict)))

  ;; Create an account with 10 coins.
  (define new-account (lambda (name)
    (modify-ref accounts (lambda (acc)
      (insert name 10 acc)))))

  ;; Get an account's balance
  (define account-balance (lambda (name)
    (lookup name (read-ref accounts))))

  ;; Transfer money
  (define transfer (lambda (from to amount)
    (define acc (read-ref accounts))
    (write-ref accounts (if (> amount (lookup from acc))
            (print! "not enough balance")
            (modify-map
              to
              (lambda (x) (+ x amount))
              (modify-map from (lambda (x) (- x amount)) acc))))))

  (define dispatch (lambda (m)
    (if (eq? m 'new-account) new-account
    (if (eq? m 'account-balance) account-balance
    (if (eq? m 'transfer) transfer
        (print! "error: currency- unknown message"))))))
  dispatch))

(define currency (create-currency))


(define new-eval (lambda (expr)
  (if (eq? (head expr) 'new-account)
      ((currency 'new-account) (head (tail expr)))
  (if (eq? (head expr) 'account-balance)
      ((currency 'account-balance) (head (tail expr)))
  (if (eq? (head expr) 'transfer)
      ((currency 'transfer) (head (tail expr)) (head (tail (tail expr))) (head
          (tail
                      (tail (tail expr)))))
  (print! "transaction must be new-account, transfer, or account-balance"))))))


;; The Repl

(define repl
  (dict
     name "repl"
     ;; Parse errors are thrown here
     getter (lambda () (catch 'parse-error (get-line!) print!))))

(catch 'any
    (subscribe-to! repl print!)
    (lambda (x) (print! x) (subscribe-to! repl print!)))
