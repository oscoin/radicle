# Chains

By now you've seen some of `radicle`, but we haven't touched upon what makes it
different from other languages.

## The execution context

The most familiar way to think about a program execution is as happening on one
particular machine. *Which* machine that is often matters to understanding how
the program behaves; a program might after all read from a file, for example,
and behave differently based on whether that file exists, and what it's
contents are. But other machines may not have that file, or have one that
differs in some way.

This aspect of program execution is often a source of headache for developers,
as it leads to hard-to-reproduce or -predict behavior. But--and more
importantly for our purposes--it also means we can't think of programs in the
abstract

In other words, we would like for programs to be *deterministic*.

TODO: more.

## Exploring remote chains

First we start up a simple server that hosts remote chains on port 8000.

```
stack run -- radicle-server
```

Now we can start a radicle REPL that will be able to communicate with
the remote chain.

```
stack run -- radicle-client rad/repl.rad
```

We start of by sending an expression to the chain that defines the atom `foo`.

```
(send! "http://localhost:8000/chains/my-first-chain" '(def foo :bar))
```

After the expression has been submitted all expression submitted
subsequently will have access to the atom `foo` defined as the keyword
`:bar`.

Using another REPL we can use the `:enter-chain` macro to inspect the
remote chain.

```
(:enter-chain "http://localhost:8000/chains/my-first-chain")
foo   ;; ==> :bar
:quit
```

Every expression put into the REPL after the `:enter-chain` macro will
be evaluated in the context of the chain. The special `:quit` macro
will leave the chain context and revert to the original REPL context.
