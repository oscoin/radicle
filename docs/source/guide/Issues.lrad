In this example we will create a chain which stores some issues about a code
repository.

This is a literate radicle file, which means you can run it like this: `stack exec doc -- docs/source/guide/Issues.lrad`.

First we load the prelude

    (load! "rad/prelude.rad")

We'll use two refs, one to store the next issue ID, and one to store the issues themselves, as a dictionary from issue IDs to issues.

    (def last-issue-id (ref -1))
    
    (def issues (ref {}))

We'll need a utility function for creating new IDs:

    (def new-issue-id
      (fn []
        (modify-ref last-issue-id (fn [i] (+ i 1)))))

Next we'll define a function for creating a new issue. An issue is a dict which
looks like:

    (def example-issue
      { :author "xyz345" ;; user id / public key
        :title  "I want pattern matching"
        :body   "I can't continue using radicle without it."
      })

    { :author   "xyz345"
      :title    "I want pattern matching"
      :body     "I can't continue using radicle without it."
      :comments [{:author "abc123" :comment "That would be amazing!"}
                 {:author "ghc173" :comment "+1"}
                ]
    }

To add an issue we just update `issues` with a new issue id:

    (def new-issue
      (fn [i]
        (modify-ref
          issues
          (fn [is] (insert (new-issue-id) i is)))))

Closing an issue is also easy:

    (def close-issue
      (fn [id]
        (modify-ref
          issues
          (fn [is] (delete id is)))))

And now the new eval function:

Now we can define the evaluation function:

    (def add-comment
      (fn [id c]
        (over-ref issues
                  (.. (@ id) (@ :comments))
                  (fn [mcs] (maybe mcs [c] (fn [cs] (add-right c cs)))))))
    (def process-command
      (fn [expr]
        (def command (head expr))
        (def arg (head (tail expr)))
        (cond
          (eq? command 'create) (new-issue arg)
          (eq? command 'close)  (close-issue arg)
          ;; (eq? command 'comment) (add-comment arg (head (tail (tail expr))))
          :else                 (throw 'invalid-command (show command)))
        (print! (read-ref issues))
        :ok))

Now we update the eval to this eval:

    (def-rec eval
      (fn [expr st]
        (set-current-env-with st 'expr expr)
        (process-command expr)
        (list :ok (get-current-env))))

And test some inputs:

    (create {:author "James" :title "Pattern matches" :body "Pleeease" :comments []})
    (create {:author "Julian" :title "Better numbers" :body "The ids are floats!" :comments []})
    (comment 0 "super")

Now it would be nice to be able to comment on issues. For this we'll just use a
`:comment` field in the issue, which is just a vector of comments. So now issues
can look like this:
So we'll add a new command `comment`. First let's make the command handler
function `add-comment`. Because things are starting to get a little nested,
we'll use lenses which are a way to get, set and modify data that's nested in
other data. In this case we want to 
