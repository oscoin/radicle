# Issues chain

## Adding an removing issues

In this example we will create a chain which stores some issues about a code
repository. At the start it will only support adding and removing issues, but then
we will add more features.

This is a literate radicle file, which means you can run it like this: `stack
exec doc -- docs/source/guide/Issues.lrad`.

First we load the prelude:

    (load! "rad/prelude.rad")

We'll use a ref to store the issues, as a dictionary from issue IDs to issues.
    
    (def issues (ref {}))

We need a way of creating new IDs for issues. Our IDs will just be incrementing
integers. What we need is a function which returns these integers, one by one,
as it is called. There is a function in the prelude for creating such functions
called `make-counter`, so we can just create our counter like this:

    (def issue-id-counter (make-counter))
    (def new-issue-id (lookup :next issue-id-counter))
    
The `make-counter` function is nothing special; it is defined like so:

     (def make-counter
       (fn []
         (def i (ref -1))
         {:next-will-be (fn [] (+ 1 (read-ref i)))
          :next         (fn [] (modify-ref i (fn [x] (+ x 1))))}))

So every time it is called it creates a new reference `i` which is in the scope
of the function that is returned. Every time `make-counter` is called, a new ref
is created, so different counters count different things! When we make a call to
`make-counter` in our chain, the ref `i` that it creates and stores in the closure
of `new-issue-id` becomes part of the _implicit_ state of the chain. We could
keep track of the next issue ID to use explicitely in a top-level ref, but it's
best to hide these sorts of details if they are not relevant to the domain.

The `make-counter` function uses `modify-ref`, a function which takes a ref and
a function. It updates the value held in the ref using the function and then
returns the _new_ value. We'll be modifying `issues` a lot, so let's create a
function for that:

    (def mod-issues
      (fn [f] (modify-ref issues f)))

Next we'll define a function for creating a new issue. An issue is a dict which
looks like:
    
    { :author "xyz345" ;; user id / public key
      :title  "I want pattern matching"
      :body   "I can't continue using radicle without it."
    }

To add an issue we just add it to the `issues` dict, using a new issue id as the
key:

    (def new-issue
      (fn [i]
        (mod-issues
          (fn [is] (insert (new-issue-id) i is)))))

Closing an issue is also easy--we just delete that issue from the dict:

    (def close-issue
      (fn [id]
        (mod-issues (fn [is] (delete id is)))))

The behaviour we want from our chain is to accept some commands to perform
issue-related tasks. We'll store these commands in a dict, keyed by the command
symbol. We put the whole thing in a ref so that we can add more commands later,
or even update existing commands.

    (def commands
      (ref
        {'create new-issue
         'close  close-issue}))

Now we create a function for handling these commands. We assume that the input
is a list with at least 2 elements, the first of which is a symbol describing
the command. We look up the command handler in the `commands` ref and then run
it on the arguments using `apply`, which calls a function on a list of
arguments. Finally we print the issues so that we can see how the state evolves.

    (def process-command
      (fn [expr]
        (def command (head expr))
        (def args    (tail expr))
        (def do-this (lookup command (read-ref commands)))
        (apply do-this args)
        (print! (read-ref issues))
        :ok))

Now we update the eval. We will check for a special command `update` for
updating the semantics of our chain (by executing arbitrary code), but otherwise
we delegate to `process-command`. In general of course you wouldn't want to
leave such an `update` command with no restrictions; we'll talk about that
later.

TODO: talk about that later.
TODO: this eval is messy, use more/better helper functions.

    (def eval
      (fn [expr state]
        (print! expr)
        (list-with-head
          expr
          (fn [cmd]
            (if (eq? cmd 'update)
              (base-eval (nth 1 expr) state)
              (eval-fn-app state 'process-command expr print!)))
          (fn [] (eval-fn-app state 'process-command expr print!)))))

Now we can start creating some issues:

    (create {:author "james"
             :title "Pattern matching"
             :body "Pleeease"})
    
    (create {:author "julian"
             :title "Better numbers"
             :body "The ids are floats!"})

## Comments on issues

Now it would be nice to be able to comment on issues. For this we'll just use a
`:comment` field in the issue, which will be a vector of comments. The first
thing we need to do therefore is add an empty vector of comments to all our
current issues. To do this we'll use the update command which allows us to run
some arbitrary updating code:

    (update
      (modify-ref issues
                  (fn [is]
                    (map-values (fn [i] (insert :comments [] i))
                                is))))

When creating issues now we need to be careful to add the comments:

    (create {:author   "Alice"
             :title    "Can issues have comments please?"
             :body     "So that we can talk about them."
             :comments []})

A more sophisticated handler might add an empty comments field if it doesn't
exist.

To add the commenting feature, first we will add a new function to add comments
to issues.

    (update
      (def add-comment
        (fn [issue-id comment]
          (mod-issues
            (fn [is]
              (modify-map issue-id
                          (fn [i]
                            (modify-map :comments
                                        (fn [cs] (add-right comment cs)) 
                                        i))
                          is))))))

TODO: modify-map should be renamed to modify-dict

You'll note that there is a lot of painful nested updating going on; later we
will see how this can be made a lot easier with lenses.

Adding this command to our comma
nds dictionary will now make comments work:

    (update
      (modify-ref
        commands
        (fn [cs] (insert 'comment add-comment cs))))

Now we can comments on issues:

    (comment 1 {:author  "James"
                :comment "Yes that is a good idea."})

## Validating data

It would be nice to validate issues and comments before they are added, e.g.
checking if all the right keys exist.

TODO

## Verifying authors

This chain has issues and comments coming from users but there is nothing that
enforces that the issues and comments are actually submitted by these users. I
(Alice) could easily submit the comment:

   (update
     { :author "bobs-id"
       :comment "LGTM"})

to the chain and no one would know it wasn't Bob. To remedy this we will use
signatures. First of all we will assume that this chain has a unique ID:

    (update
      (def chain-id "some-unique-name"))

Next, we will give all comments a unique ID, to avoid replay attacks, for this
we use another counter:

    (update
      (do
        (def comment-id-counter (make-counter))
    
        (def new-comment-id  (lookup :next         comment-id-counter))
        (def next-comment-id (lookup :next-will-be comment-id-counter))))

This time we are also going to use `next-comment-id` which tells us what the
next ID to be generated is, without incrementing the counter.

Now a comment will look like this:

    (update
      { :author    "key here"
        :comment   "some-text"
        :signature "signature here"})

Signatures are creatied using the `gen-signature!` function, it takes a secret
key `sk` and a string `msg`. The signature `sig` that it returns can be used
with the function `verify-signature` as follows: `(verify-signature pk sig
msg)`. If this returns `#t` then this tells us that the person who signed the
message is the person who knows the secret key.

So let's make a utility function for creating signed comments. Note that usually
this function would _not_ be part of the chain, since it contains effectful
code.

    (update
      (def make-comment
        (fn [sk pk text]
          (def comment-id (next-comment-id))
          (def msg (string-append chain-id comment-id text))
          {:id comment-identifiers
           :author pk
           :comment text
           :signature (gen-signature! sk msg)})))

On the chain we can create a function to verify comments are valid:

    (update
      (def comment-valid?
        (fn [c]
          (def id (next-comment-id))
          (and (eq? (lookup :id c) id)
               (verify-signature (lookup :author c)
                                 (lookup :signature c)
                                 (string-append chain-id (show id) (lookup :comment c)))))))

Finally we modify the `add-comment` function. Note that we re-use our old
add-comment function, just adding the extra layer of security:

    (update
      (def add-verified-comment
        (fn [issue-id comment]
          (if (comment-valid? comment)
              (add-comment issue-id comment)
              ;; In a real chain we would throw, not print a message.
              (print! "The comment was not valid.")
              ))))

And we update our commands:

    (update
      (modify-ref
        commands
        (fn [cs] (insert 'comment add-verified-comment cs))))

Comments have to be signed to be valid, here is some code one could run in
another file to create such comments:

    ;; (def chain-id "some-unique-name")
    ;;
    ;; Generate a comment.
    ;;   sk: private key
    ;;   pk: public key
    ;;   comment-id: the next comment id
    ;;   text: the text of the comment.
    ;; (def make-comment
    ;;   (fn [sk pk comment-id text]
    ;;     (def msg (string-append chain-id (show comment-id) text))
    ;;     {:id comment-id
    ;;      :author pk
    ;;      :comment text
    ;;      :signature (gen-signature! sk msg)}))

To generate the first valid comment we can now call:

    (make-comment sk pk 0 "hello")

And submit the result to the chain:

    (comment 0
      {:author [:PublicKey
       {:public_curve [:CurveFP
        [:CurvePrime
        1.15792089237316195423570985008687907853269984665640564039457584007908834671663e77
        [:CurveCommon
        {:ecc_a 0.0
         :ecc_b 7.0
         :ecc_g [:Point
         5.506626302227734366957871889516853432625060345377759417550018736038911672924e76
         3.2670510020758816978083085130507043184471273380659243275938904335757337482424e76]
         :ecc_h 1.0
         :ecc_n 1.15792089237316195423570985008687907852837564279074904382605163141518161494337e77}]]]
        :public_q [:Point
        9.2931283663690685721504325504640475411994819428791269001243764662744013425099e76
        3.6596591984233286089056041079822336001174921649384520024155197534940746477932e76]}]
       :comment "hello"
       :id 0.0
       :signature [:Signature
       {:sign_r 1.01192636226738430105958167746173122946852303538902797009132349695443307988401e77
        :sign_s 5.8543237989708509717277607902528553462065125985173573031888935675327120728182e76}]})

Signing issues would be done in a similar way.
