# Issues chain

## Adding an removing issues

In this example we will create a chain which stores some issues about a code
repository. At the start it will only support adding a removing issues, but then
we will add more features.

This is a literate radicle file, which means you can run it like this: `stack
exec doc -- docs/source/guide/Issues.lrad`.

First we load the prelude:

    (load! "rad/prelude.rad")

We'll use a ref to store the issues, as a dictionary from issue IDs to issues.
    
    (def issues (ref {}))

We need a way of creating new IDs for issues. Our IDs will just be incrementing
integers. What we need is a function which returns these integers, one by one,
as it is called. There is a function in the prelude for creating such functions
called `make-counter`, so we can just create our counter like this:

    (def new-issue-id (make-counter))
    
The `make-counter` function is nothing special, it is defined like so:

    (def make-counter
      (fn []
        (def i (ref -1))
        (fn []
          (modify-ref i (fn [x] (+ x 1))))))

So every time it is called it creates a new reference `i` which is in the scope
of the function that is returned. Every time `make-counter` is called, a new ref
is created, so different counters count different things! When we make a call to
make-counter in our chain, the ref `i` that it creates and stores in the closure
of `new-issue-id` becomes part of the _implicit_ state of the chain. We could
keep track of the next issue ID to use explicitely in a top-level ref, but it's
best to hide these sorts of details if they are not relevant to the domain.

The `make-counter` function uses `modify-ref`, a function which takes a ref and
a function. It updates the value held in the ref using the function and then
returns the _new_ value. We'll be modifying `issues` a lot, so let's create a
function for that:

    (def mod-issues
      (fn [f] (modify-ref issues f)))

Next we'll define a function for creating a new issue. An issue is a dict which
looks like:
    
    { :author "xyz345" ;; user id / public key
      :title  "I want pattern matching"
      :body   "I can't continue using radicle without it."
    }

To add an issue we just add it to the `issues` dict, using a new issue id as the
key:

    (def new-issue
      (fn [i]
        (mod-issues
          (fn [is] (insert (new-issue-id) i is)))))

Closing an issue is also easy, we just delete that issue from the dict:

    (def close-issue
      (fn [id]
        (mod-issues (fn [is] (delete id is)))))

The behaviour we want from our chain is to accept some commands to perform
issue-related tasks. We'll store these commands in a dict, keyed by the command
symbol. We put the whole thing in a ref so that we can add more commands later,
or even update existing commands.

    (def commands
      (ref
        {'create new-issue
         'close  close-issue}))

Now we create a function for handling these commands. We assume that the input
is a list with at least 2 elements, the first of which is a symbol describing
the command. We look up the command handler in the `commands` ref and then run
it on the arguments using `apply`, which calls a function on a list of
arguments. Finally we print the issues so that we can see how the state evolves.

    (def process-command
      (fn [expr]
        (def command (head expr))
        (def args    (tail expr))
        (def do-this (lookup command (read-ref commands)))
        (apply do-this args)
        (print! (read-ref issues))
        :ok))

Now we update the eval. We will check for a special command `update` for
updating the semantics of our chain (by executing arbitrary code), but otherwise
we delegate to `process-command`. In general of course you wouldn't want to
leave such an `update` command with no restrictions; we'll talk about that
later.

TODO: talk about that later.
TODO: this eval is messy, use more/better helper functions.

    (def eval
      (fn [expr state]
        (print! expr)
        (list-with-head
          expr
          (fn [cmd]
            (if (eq? cmd 'update)
              (base-eval (nth 1 expr) state)
              (eval-fn-app state 'process-command expr print!)))
          (fn [] (eval-fn-app state 'process-command expr print!)))))

Now we can start creating some issues:

    (create {:author "james"
             :title "Pattern matching"
             :body "Pleeease"})
    
    (create {:author "julian"
             :title "Better numbers"
             :body "The ids are floats!"})

## Comments on issues

Now it would be nice to be able to comment on issues. For this we'll just use a
`:comment` field in the issue, which is just a vector of comments. The first
thing we need to do therefore is add an empty vector of comments to all our
current issues. To do this we'll use the update command which allows us to run
some arbitrary updating code:

    (update
      (modify-ref issues
                  (fn [is]
                    (map-values (fn [i] (insert :comments [] i))
                                is))))

When creating issues now we need to be careful to add the comments:

    (create {:author   "Alice"
             :title    "Can issues have comments please?"
             :body     "So that we can talk about them."
             :comments []})

A more sophisticated handler might add an empty comments field if it doesn't
exist.

To add the commenting feature, first we will add a new function to add comments
to issues.

    (update
      (def add-comment
        (fn [issue-id comment]
          (mod-issues
            (fn [is]
              (modify-map issue-id
                          (fn [i]
                            (modify-map :comments
                                        (fn [cs] (add-right comment cs)) 
                                        i))
                          is))))))

TODO: modify-map should be renamed to modify-dict

You'll note that there is a lot of painful nested updating going on; later we
will see how this can be made a lot easier with lenses.

Adding this command to our comma
nds dictionary will now make comments work:

    (update
      (modify-ref
        commands
        (fn [cs] (insert 'comment add-comment cs))))

Now we can comments on issues:

    (comment 1 {:author  "James"
                :comment "Yes that is a good idea."})

## Validating data

It would be nice not to add invalid issues/comments

## Verifying authors

Using signatures
