(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
        (print! (string-append "Test '" name "' failed")))))

;; empty?
(define empty? (lambda (ls) (eq? ls (list))))
(should-be "empty" (empty? (list 2)) #f)

;; y-combinator
(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

;; reverse
(define reverse (lambda (ls)
  (define go (Y2 (lambda (go)
    (lambda (acc new)
      (if (empty? new)
          acc
          (go (cons (head new) acc) (tail new)))))))
  (go (list) ls)))

(should-be "reverse" (reverse (list 1 2 3)) (list 3 2 1))

;; range
(define range (Y2 (lambda (range) (lambda (from to)
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(should-be "range" (range 1 5) (list 1 2 3 4 5))

;; filter
(define filter (Y2 (lambda (filter) (lambda (cond ls)
  (if (empty? ls)
      ls
  (if (cond (head ls))
      (cons (head ls) (filter cond (tail ls)))
      (filter cond (tail ls))))))))

(should-be "filter"
  (filter (lambda (x) (< x 10)) (list 3 10 11))
  (list 3))

;; modify-ref
(define modify-ref (lambda (ref fn)
  (write-ref ref (fn (read-ref ref)))))

;; modify-map
(define modify-map (lambda (key fn mp)
  (insert key (fn (lookup key mp)) mp)))

(should-be "modify-map"
  (modify-map 'a (lambda (x) (+ x 1)) (dict 'a 5))
  (dict 'a 6))

;; Account stuff. Should be moved elsewhere when we have an import mechanism

(define create-currency (lambda ()

  ;; The map of all accounts
  (define accounts (ref (dict)))

  ;; Create an account with 10 coins.
  (define new-account (lambda (name)
    (modify-ref accounts (lambda (acc)
      (insert name 10 acc)))))

  ;; Get an account's balance
  (define account-balance (lambda (name)
    (lookup name (read-ref accounts))))

  ;; Transfer money
  (define transfer (lambda (from to amount)
    (define acc (read-ref accounts))
    (write-ref accounts (if (> amount (lookup from acc))
            (print! "not enough balance")
            (modify-map
              to
              (lambda (x) (+ x amount))
              (modify-map from (lambda (x) (- x amount)) acc))))))

  (define dispatch (lambda (m)
    (if (eq? m 'new-account) new-account
    (if (eq? m 'account-balance) account-balance
    (if (eq? m 'transfer) transfer
        (print! "error: currency- unknown message"))))))
  dispatch))

(define currency (create-currency))


(define new-eval (lambda (expr)
  (if (eq? (head expr) 'new-account)
      ((currency 'new-account) (head (tail expr)))
  (if (eq? (head expr) 'account-balance)
      ((currency 'account-balance) (head (tail expr)))
  (if (eq? (head expr) 'transfer)
      ((currency 'transfer) (head (tail expr)) (head (tail (tail expr))) (head
          (tail
                      (tail (tail expr)))))
  (print! "transaction must be new-account, transfer, or account-balance"))))))

;; Chains

(define empty-state (dict 'env (dict 'eval base-eval) 'refs (list)))
(define empty-chain (dict 'state empty-state 'logs (list)))
(define chains (dict 'a empty-chain 'b empty-chain))

;; The Repl

(define repl
  (dict
     'name "repl"
     ;; Parse errors are thrown here
     'getter (lambda () (catch 'parse-error (get-line!) print!))))

(catch 'any
    (subscribe-to! repl print!)
    (lambda (x) (print! x) (subscribe-to! repl print!)))
