(define document
  (lambda (name args description)
    (define old (read-ref _doc-ref))
    (write-ref
       _doc-ref
       (insert name (dict :args args :desc description) old))))

(document 'document
  '(("name" atom) '("args" list) '("description" desc))
  "Documents an atom. The documentation can then be retrieved with '(doc name)'.")

;; doc

(define doc
  (lambda (name)
    (define the-doc (lookup name (read-ref _doc-ref)))
    (string-append
       (lookup :desc the-doc)
       "\nArguments:\n\t"
       (show (lookup :args the-doc)))))

(document 'doc
  '(("name" atom))
  "Retrieves the documentation for an atom, if there is any.")

;; should-be

(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
      (print! (string-append "Test '" name "' failed")))))

(document 'should-be
  '(("test-name" string) ("actual" any) ("expected" any))
  "Checks that 'actual' equals 'expected'. Used for tests")

(should-be "doc" (string? (doc 'doc)) #t)

;; y-combinators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

(load! "rad/prelude/bool.rad")
(load! "rad/prelude/list.rad")
(load! "rad/prelude/dict.rad")
(load! "rad/prelude/ref.rad")
(load! "rad/prelude/lens.rad")

;; Issues for rad prelude

(define create-rad-issue-chain (lambda ()
  (define issues (ref nil))
  (define should-be (lambda (name x y) (eq? x y)))
  (define current-prelude (ref (dict :env (dict 'should-be should-be 'eval eval) :refs nil)))


  (define failing? (lambda (expr)
    (define res (catch 'any
                       (head (eval-with-env expr (read-ref current-prelude)))
                       (lambda (x) #f)))
    (eq? res #f)))

  (define new-issue (lambda (creator title desc failing-test)
    (if (failing? failing-test)
        (modify-ref
          issues
          (lambda (x)
            (cons (dict
              :creator creator
              :title title
              :description desc
              :failing-test failing-test) x)))
        "Test is not failing")))

  (define list-issues (lambda () (read-ref issues)))

  (define dispatch (lambda (m)
    (if (eq? m 'new-issue) new-issue
    (if (eq? m 'list-issues) list-issues
        "error: unknown message"))))

  dispatch))

(define rad-issue-chain (create-rad-issue-chain))

(define rad-issue-chain-eval (lambda (expr)
     (if (eq? (head expr) 'new-issue)
         (apply (rad-issue-chain 'new-issue) (tail expr))
     (if (eq? (head expr) 'list-issues)
         ((rad-issue-chain 'list-issues))
         "must be one of: 'new-issue', 'list-issues'"))
     ))

;; The Repl

(define _initial_prompt-text
  "Welcome to radicle. Type (help) for help.")

(define help (lambda ()
  "radicle is a LISP-like language intendended for programming chains, and
  interacting with those chains.

  Type (doc <name>) for further documentation of <name>."))


(define repl
  (dict
     'name "repl"
     ;; Parse errors are thrown here
     'getter (lambda () (catch 'parse-error (get-line!) print!))))

(catch 'any
    (subscribe-to! repl print!)
    (lambda (x) (print! x) (subscribe-to! repl print!)))
