(define document
  (lambda (name args description)
    (define old (read-ref _doc-ref))
    (write-ref
       _doc-ref
       (insert name (dict :args args :desc description) old))))

(document 'document
  '(("name" atom) '("args" list) '("description" desc))
  "Documents an atom. The documentation can then be retrieved with '(doc name)'.")

;; doc

(define doc
  (lambda (name)
    (define the-doc (lookup name (read-ref _doc-ref)))
    (string-append
       (lookup :desc the-doc)
       "\nArguments:\n\t"
       (show (lookup :args the-doc)))))

(document 'doc
  '(("name" atom))
  "Retrieves the documentation for an atom, if there is any.")

;; should-be

(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
      (print! (string-append "Test '" name "' failed")))))

(document 'should-be
  '(("test-name" string) ("actual" any) ("expected" any))
  "Checks that 'actual' equals 'expected'. Used for tests")

(should-be "doc" (string? (doc 'doc)) #t)


;; boolean functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; not

(define not (lambda (x) (if x #f #t)))

(document 'not
  '(("arg" any))
  "True if 'arg' is #f, false otherwise.")

;; and

(define and
  (lambda (x y)
    (if x y x)))

(document 'and
  '(("arg1" any) ("arg2" any))
  "Returns 'arg2' if 'arg1' is not #f, otherwise returns 'arg1'")

(should-be "and" (and #t #t) #t)
(should-be "and" (and #t #f) #f)
(should-be "and" (and #f #t) #f)
(should-be "and" (and #f #f) #f)

;; or

(define or
  (lambda (x y)
    (if x x y)))

(document 'or
  '(("arg1" any) ("arg2" any))
  "Returns 'arg1' if 'arg1' is not #f, otherwise returns 'arg2'")

(should-be "or" (or #t #t) #t)
(should-be "or" (or #t #f) #t)
(should-be "or" (or #f #t) #t)
(should-be "or" (or #f #f) #f)

;; all

(define all
  (lambda (xs) (foldr and #t xs)))

(should-be "all" (all '()) #t)
(should-be "all" (all '(#t)) #t)
(should-be "all" (all '(#f)) #f)
(should-be "all" (all '(#t #t #t #t)) #t)
(should-be "all" (all '(#t #t #f #t)) #f)

;; some

(define some
  (lambda (xs) (foldr or #f xs)))

(should-be "some" (some '()) #f)
(should-be "some" (some '(#t)) #t)
(should-be "some" (some '(#f)) #f)
(should-be "some" (some '(#f #f #f)) #f)
(should-be "some" (some '(#t #t #t #t)) #t)
(should-be "some" (some '(#t #t #f #t)) #t)

;; y-combinators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

;; List functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; nil

(define nil (list))

;; empty?

(define empty? (lambda (ls) (eq? ls nil)))

(document 'empty?
  '(("list" list))
  "True if 'list' is empty, false otherwise.")

(should-be "empty" (empty? (list 2)) #f)


;; length

(define length
  (lambda (xs)
    (foldr (lambda (x acc) (+ acc 1)) 0 xs)))

(document 'length
  '(("list" list))
  "Returns the length of 'list'.")

(should-be "length" (length nil) 0)
(should-be "length" (length (list 2)) 1)

;; reverse

(define reverse (lambda (ls)
  (define go (Y2 (lambda (go)
    (lambda (acc new)
      (if (empty? new)
          acc
          (go (cons (head new) acc) (tail new)))))))
  (go (list) ls)))

(document 'reverse
  '(("list" list))
  "Returns the reversed 'list'.")

(should-be "reverse" (reverse (list 1 2 3)) (list 3 2 1))

;; range

(define range (Y2 (lambda (range) (lambda (from to)
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(document 'range
  '(("start" number) ("end" number))
  "Returns a list with all integers from 'start' to 'end', inclusive.")

(should-be "range" (range 1 5) (list 1 2 3 4 5))

;; concat

(define concat (lambda (list1 list2)
  (foldr (lambda (a b) (cons a b)) list2 list1)))

(document 'concat
  '(("list1" list) ("list2" list))
  "Concatenates 'list1' and 'list2'.")

(should-be "concat" (concat '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6))


;; filter

(define filter (Y2 (lambda (filter) (lambda (pred ls)
  (if (empty? ls)
      ls
  (if (pred (head ls))
      (cons (head ls) (filter pred (tail ls)))
      (filter pred (tail ls))))))))

(document 'filter
  '(("filter-cond" function) ("list" list))
  "Returns 'list' with only the elements that satisfy 'filter-cond'.")

(should-be "filter"
  (filter (lambda (x) (< x 10)) (list 3 10 11))
  (list 3))

;; dict functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; dict-from-list

(define dict-from-list
  (lambda (xs)
    (foldr (lambda (kv acc) (insert (head kv) (head (tail kv)) acc)) (dict) xs)))

(document 'dict-from-list
  '(("list" list))
  "Creates a dictionary from a list of key-value pairs.")

(should-be "dict-from-list"
           (dict-from-list (list (list :one 1) (list :two 2)))
           (dict :one 1 :two 2))

;; keys

(define keys
  (lambda (d)
    (map (lambda (x) (head x)) (seq d))))

(document 'keys
  '(("dict" dict))
  "Returns the list of keys in a dictionary.")

;; Uncomment this test once map is fixed.
;; (should-be "keys"
;;            (keys (dict :one 1 :two 2))
;;            '(:one :two))


;; modify-map
(define modify-map (lambda (key fn mp)
  (insert key (fn (lookup key mp)) mp)))

(should-be "modify-map"
  (modify-map 'a (lambda (x) (+ x 1)) (dict 'a 5))
  (dict 'a 6))

;; ref functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; modify-ref
(define modify-ref
  (lambda (r fn)
    (write-ref r (fn (read-ref r)))))

(document 'modify-ref
  '(("ref" ref) ("fn" function))
  "Modify 'ref' by applying the provided function.")

;; Lenses ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; make-lens

(define make-lens
  (lambda (g s)
    (dict 'getter g 'setter s)))

(document 'make-lens
  '(("getter" function) ("setter" function))
  "Makes a lens out of a getter and a setter.")

;; view

(define view
  (lambda (lens target)
    ((lookup 'getter lens) target)))

(document 'view
  '(("lens" dict) ("target" any))
  "View a value through a lens.")

;; set

(define set
  (lambda (lens new-view target)
    ((lookup 'setter lens) new-view target)))

(document 'set
  '(("lens" dict) ("value" any) ("target" any))
  "Set a value though a lens.")

;; id-lens

(define id-lens
  (make-lens
   (lambda (target) target)
   (lambda (new-view target) new-view)))

(document 'id-lens
  '()
  "The identity lens.")

;; ..

(define ..
  (lambda (lens1 lens2)
    (make-lens
     (lambda (target) (view lens2 (view lens1 target)))
     (lambda (new-view target) (set lens1 (set lens2 new-view (view lens1 target)) target)))))

(document '..
  '(("lens1" dict) ("lens2" dict))
  "Compose two lenses.")

;; ...

(define ... (lambda (lenses) (foldr .. id-lens lenses)))

(document '...
  '(("lenses" list))
  "Compose multiple lenses.")

;; over
(define over
  (lambda (lens f target)
    (set lens (f (view lens target)) target)))

(document 'over
  '(("lens" dict) ("fn" function) ("target" any))
  "Modify a value through a lens.")

;; @

(define @
  (lambda (k)
    (make-lens (lambda (mp) (lookup k mp))
               (lambda (v mp) (insert k v mp)))))

(document '@
  '(("key" any))
  " Returns a lens targetting keys of dicts.")

(should-be "view lens"
           (view (@ :one) (dict :one 1 :two 2))
           1)

(should-be "set lens"
           (set (@ :two) 42 (dict :one 1 :two 2))
           (dict :one 1 :two 42))

(should-be "over lens"
           (over (@ :one) (lambda (x) (+ x 1)) (dict :one 1 :two 2))
           (dict :one 2 :two 2))

(should-be "lens composition"
           (over (.. (@ :a) (@ :b))
                 (lambda (x) (+ x 1))
                 (dict :a (dict :b 2)))
           (dict :a (dict :b 3)))

(do (define d
      (lambda (x) (dict :a (dict :b (dict :c x)))))
    (should-be "deep lenses"
               (over (... (list (@ :a) (@ :b) (@ :c)))
                     (lambda (x) (+ x 1))
                     (d 0))
               (d 1)))

;; Lens access to refs

;; view-ref
(define view-ref
  (lambda (r lens)
    (view lens (read-ref r))))

(document 'view-ref
  '(("ref" ref) ("lens" dict))
  "Like 'view', but for refs.")

(should-be "view-ref"
           (view-ref (ref (dict :key 1)) (@ :key))
           1)

;; set-ref

(define set-ref
  (lambda (r lens v)
    (modify-ref r (lambda (x) (set lens v x)))))

(document 'set-ref
  '(("ref" ref) ("lens" dict) ("new-value" any))
  "Like 'set', but for refs.")

(should-be "set-ref"
           (do (define r (ref (dict :a 1)))
               (set-ref r (@ :a) 2)
               (view-ref r (@ :a)))
           2)
;; set-ref

(define over-ref
  (lambda (r lens f)
    (modify-ref r (lambda (x) (over lens f x)))))

(document 'over-ref
  '(("ref" ref) ("lens" dict) ("fn" function))
  "Like 'over', but for refs.")

(should-be "over-ref"
           (do (define r (ref (dict :a 2)))
               (over-ref r (@ :a) (lambda (x) (* x 2)))
               (view-ref r (@ :a)))
           4)

;; paper examples

(define sas-password "very secret")
(define sas-store (ref (dict)))
(define sas-eval-ref (ref eval))

;; self-amending key-val store
(define sas-starting-eval
  (lambda (expr)
    (define command (head expr))
    (cond
     (eq? command 'get) (lookup (nth 1 expr) (read-ref sas-store))
     (eq? command 'set) (modify-ref sas-store (lambda (s) (insert (nth 1 expr) (nth 2 expr) s)))
     (and (eq? command 'update)
          (eq? (nth 1 expr)
               sas-password))
     (write-ref sas-eval-ref (eval (nth 2 expr)))
     :else (throw 'invalid-command "Valid commands are: 'get', 'set' and 'update'."))))

;; Handle an input in the morphing state-machine.
(define state-machine-input
  (lambda (state i)
    (define upd (lambda (s) ((view-ref state (@ :transition-fn)) s i)))
    (over-ref state (@ :machine-state) upd)
    (string-append "ACCEPTED! new state: " (show (view-ref state (@ :machine-state))))))

;; Trigger a new vote
(define state-machine-new-trans
  (lambda (state func)
    (if (eq? (view-ref state (@ :voting)) :nothing)
        (do (set-ref state (@ :voting) (dict :votes (dict)
                                             :proposed-function func))
          (string-append "A new transition function has been proposed! Please either agree or disagree with: " (show func)))
      (throw 'invalid-input "Can't propose new transition function while vote is ongoing."))))

(define state-machine-agree
  (lambda (state voters userid)
    (if (member? userid voters)
        (do (set-ref state (... (list (@ :voting) (@ :votes) (@ userid))) #t)
            (if (eq? (length (seq (view-ref state (.. (@ :voting) (@ :votes))))) (length voters))
                (do (set-ref state (@ :transition-fn) (eval (view-ref state (.. (@ :voting) (@ :proposed-function)))))
                    (set-ref state (@ :voting) :nothing)
                    "Voting has finished; a new transition function is in effect.")
                '()))
        (throw 'invalid-input "Not allowed to vote."))))

(define state-machine-disagree
  (lambda (state voters userid)
    (if (member? userid voters)
        (do (set-ref state (@ :voting) :nothing)
            "Voting has ended; someone disagreed.")
        (throw 'invalid-input "You are not allowed to vote."))))

;; Returns an eval which operates a state machine whose transition function may
;; be updated. To update the transition function all voters must agree on it.
(define state-machine-eval
  (lambda (voters init-state init-transition)
    (define state (ref (dict :machine-state init-state
                             :transition-fn init-transition
                             :voting :nothing)))
    (lambda (expr)
      (define verb (nth 0 expr))
      (define input (nth 1 expr))
      (cond
       (eq? verb 'input)          (state-machine-input     state input)
       (eq? verb 'new-trans-func) (state-machine-new-trans state input)
       (eq? verb 'agree)          (state-machine-agree     state voters input)
       (eq? verb 'disagree)       (state-machine-disagree  state voters input)
       :else                      (throw 'invalid-input (string-append "The only valid commands are 'input', 'new-trans-func', 'agree' and 'disagree': " (show expr)))))))

(define integer-machine
  (state-machine-eval (list "alice777" "bob_1337") 0 +))

(define discussion
  (state-machine-eval (list "james" "julian")
                      ""
                      (lambda (cur inp)
                        (string-append cur "\n\n" (head inp) ": " (head (tail inp))))))

(lambda (cur inp) (string-append cur "\n" (head inp) ": " (head (tail inp))))

;; Account stuff. Should be moved elsewhere when we have an import mechanism

(define create-currency (lambda ()

  ;; The map of all accounts
  (define accounts (ref (dict)))

  ;; Create an account with 10 coins.
  (define new-account (lambda (name)
    (modify-ref accounts (lambda (acc)
      (insert name 10 acc)))))

  ;; Get an account's balance
  (define account-balance (lambda (name)
    (lookup name (read-ref accounts))))

  ;; Transfer money
  (define transfer (lambda (from to amount)
    (define acc (read-ref accounts))
    (write-ref accounts (if (> amount (lookup from acc))
            (print! "not enough balance")
            (modify-map
              to
              (lambda (x) (+ x amount))
              (modify-map from (lambda (x) (- x amount)) acc))))))

  (define dispatch (lambda (m)
    (if (eq? m 'new-account) new-account
    (if (eq? m 'account-balance) account-balance
    (if (eq? m 'transfer) transfer
        (print! "error: currency- unknown message"))))))
  dispatch))

(define currency (create-currency))


(define currency-eval (lambda (expr)
  (if (eq? (head expr) 'new-account)
      ((currency 'new-account) (head (tail expr)))
  (if (eq? (head expr) 'account-balance)
      ((currency 'account-balance) (head (tail expr)))
  (if (eq? (head expr) 'transfer)
      ((currency 'transfer) (head (tail expr)) (head (tail (tail expr))) (head
          (tail
                      (tail (tail expr)))))
  (print! "transaction must be new-account, transfer, or account-balance"))))))

;; Issues for rad prelude

(define create-rad-issue-chain (lambda ()
  (define issues (ref nil))
  (define should-be (lambda (name x y) (eq? x y)))
  (define current-prelude (ref (dict :env (dict 'should-be should-be 'eval eval) :refs nil)))


  (define failing? (lambda (expr)
    (define res (catch 'any
                       (head (eval-with-env expr (read-ref current-prelude)))
                       (lambda (x) #f)))
    (eq? res #f)))

  (define new-issue (lambda (creator title desc failing-test)
    (if (failing? failing-test)
        (modify-ref
          issues
          (lambda (x)
            (cons (dict
              :creator creator
              :title title
              :description desc
              :failing-test failing-test) x)))
        "Test is not failing")))

  (define list-issues (lambda () (read-ref issues)))

  (define dispatch (lambda (m)
    (if (eq? m 'new-issue) new-issue
    (if (eq? m 'list-issues) list-issues
        "error: unknown message"))))

  dispatch))

(define rad-issue-chain (create-rad-issue-chain))

(define rad-issue-chain-eval (lambda (expr)
     (if (eq? (head expr) 'new-issue)
         (apply (rad-issue-chain 'new-issue) (tail expr))
     (if (eq? (head expr) 'list-issues)
         ((rad-issue-chain 'list-issues))
         "must be one of: 'new-issue', 'list-issues'"))
     ))



;; Chains: Functions for dealing with chains.

;; A chain is conceptually:
;;   - A known starting state (i.e. environment, and the assumption that `eval
;;     == base-eval')
;;   - A sequence of inputs.

(define empty-state (get-current-env))

;; (define empty-state (dict
;;    :env (dict 'eval 'base-eval)
;;    :refs (list)))

(define empty-chain
  (dict :state empty-state
        :inputs (list)
        :index 0))

;; Evaluates an expression inside a chain. Returns the :result and the new
;; :chain in a dict.
(define eval-in-chain
  (lambda (expr chain)
    (define x (eval-with-env expr (lookup :state chain)))
    (dict :chain (dict :state (head (tail x))
                       :input (cons expr (lookup :logs chain))
                       :index (+ 1 (lookup :index chain)))
          :result (head x))))

;; Updates a local chain according to activity on a remote chain, by pulling
;; down and evaluating new inputs. Also accepts two callbacks: one it applies to
;; input expressions, and one it applies to results. Usually one uses `print`
;; for both of these.
;; ASSUMES that the remote chain starts with the inputs of the local chain.
(define update-chain-with
  (lambda (chain remote-chain-id cb-expr cb-res)
    (define new-inputs
      (receive! remote-chain-id (lookup :index chain)))
    (define upd-ch
      (lambda (ch expr)
        (define x (eval-in-chain expr ch))
        (cb-expr expr)
        (cb-res (view (@ :result) x))
        (view (@ :chain) x)))
    (foldl upd-ch chain new-inputs)))

;; Experiment in a local chain.
(define enter-chain
  (lambda (eval-definer chain)
    (define old-eval eval)
    (define ch (ref chain))
    (define ev
      (lambda (e)
        (if (eq? e :quit)
            (do (print! "leaving chain")
                (eval-definer old-eval))
          (do (define x (eval-in-chain e (read-ref ch)))
              (write-ref ch (view (@ :chain) x))
              (view (@ :result) x)))))
    (eval-definer ev)))

;; Syncs up to a remote chain, and allows experimentation inputs. There are two
;; special inputs:
;; - `:quit` will just leave the chain.
;; - `:send` will send all the inputs entered to the chain, in one go (wrapped
;;   in a `do`), and then leave the chain.
(define remote-chain
  (lambda (eval-definer chain-id)
    (define old-eval eval)
    (define chain (update-chain-with empty-chain chain-id (lambda (e) '()) (lambda (e) '())))
    (print! (string-append "Synced with remote chain, at index: " (show (view (@ :index) chain))))
    (define ch (ref chain))
    (define inputs (ref (list)))
    (eval-definer
     (lambda (e)
       (cond
        (eq? e :quit) (do (print! "Leaving remote-chain.")
                          (eval-definer old-eval))
        (eq? e :send) (do (print! "Sending inputs to remote chain.")
                          (map (lambda (i) (send! chain-id i)) (reverse (read-ref inputs)))
                          (print! "Done! Leaving remote-chain.")
                          (eval-definer old-eval))
        :else (do (define x (eval-in-chain e (read-ref ch)))
                  (write-ref ch (view (@ :chain) x))
                  (modify-ref inputs (lambda (is) (cons e is)))
                  (view (@ :result) x)))))))

(define boom
  (quote
   (do (define eval-ref (ref eval))
       (define eval-definer (lambda (f) (write-ref eval-ref f)))
       (define eval (lambda (e) ((read-ref eval-ref) e))))))

;; ;; A global ref storing local copies of remote chains.
;; (define chains (ref (dict "root" empty-chain "prel" empty-chain)))

;; (define update-chain (lambda (chain-name)
;;   (update-chain-with chain-name print!)))

;; (define chain-logs (lambda (chain)
;;   (lookup :logs (lookup chain (read-ref chains)))))

;; The Repl

(define _initial_prompt-text
  "Welcome to radicle. Type (help) for help.")

(define help (lambda ()
  "radicle is a LISP-like language intendended for programming chains, and
  interacting with those chains.

  Type (doc <name>) for further documentation of <name>."))


(define repl
  (dict
     'name "repl"
     ;; Parse errors are thrown here
     'getter (lambda () (catch 'parse-error (get-line!) print!))))

(catch 'any
    (subscribe-to! repl print!)
    (lambda (x) (print! x) (subscribe-to! repl print!)))
