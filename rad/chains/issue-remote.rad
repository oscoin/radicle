;; Issue chain
;; Meant to be sent to a chain with send-code!

(def issues (ref {}))

(def mod-issues
  "A helper to apply a function to `issues`"
  (fn [f] (modify-ref issues f)))

(def id-valid-and-free?
  "Checks that its argument is a `uuid` that hasn't yet been used."
  (fn [id]
    (and (uuid? id)
         (not (member? id (read-ref issues))))))

(def issue-valid?
  "Verifies the signature of an issue."
  (fn [i]
    (verify-signature (lookup :author i)
                      (lookup :signature i)
                      (string-append chain-id
                                     (lookup :id i)
                                     (lookup :title i)
                                     (lookup :body i)))))

(def new-issue
  "Create an issue from a dictionary, storing it in `issues`."
  (fn [i]
    (def id (lookup :id i))
    (if (id-valid-and-free? id)
      (mod-issues
        (fn [is] (insert id i is)))
      (throw 'bad-command "Issue ID was not free or was invalid."))))

(def close-issue
  "Remove an issue from `issues`."
  (fn [id]
    (mod-issues (fn [is] (delete id is)))))

(def add-comment
  "Add a comment to an issue."
  (fn [issue-id comment]
    (mod-issues
      (fn [is]
        (modify-map issue-id
                    (fn [i]
                      (modify-map :comments
                                  (fn [cs] (add-right comment cs))
                                  i))
                    is)))))

;; These are intended for clients to run locally with eval-in-chain

(def list-issues
  "List existing issues."
  (fn [] (read-ref issues)))

;; General logic

(def commands
  "The set of allowed chain commands."
  (ref
    {'create-issue new-issue
     'close-issue  close-issue
     'list-issues  list-issues}))

(def process-command
  "Function that maps post-eval commands to existing functions"
  (fn [expr]
    (def command (head expr))
    (def args    (tail expr))
    (def do-this (lookup command (read-ref commands)))
    (apply do-this args)))

;; Move to eval-fn-app & updatable-eval from chain.rad to a pure file so it may
;; be imported

(def eval-fn-app
  "Given a state, a function, an argument and a callback, returns
  the result of evaluating the function call on the arg in the given
  state, while also calling the callback on the result."
  (fn [state f arg cb]
    (def exec (base-eval (list f (list 'quote arg)) state))
    (cb (head exec))
    exec))

(def updatable-eval
  "Given an evaluation function `f`, returns a new one which augments `f` with a new
  command `(update expr)` which evaluates arbitrary expression using `base-eval`."
  (fn [sub-eval]
    (fn [expr state]
      (list-with-head
       expr
       (fn [cmd]
         (if (eq? cmd 'update)
           (base-eval (nth 1 expr) state)
           (sub-eval expr state)))
       (fn [] (sub-eval expr state))))))

(def eval (updatable-eval
    (fn [expr state]
      (eval-fn-app state 'process-command expr (fn [x] x)))))
