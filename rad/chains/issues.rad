;; Helpers for setting up and interacting with issues chain (as defined in
;; rad/issues-chain.rad)

;; Create a remote issue chain. Returns a ref for the chain that you
;; can assign to a variable.

(def create-issues-chain!
  "Create a remote issue chain with the given url. Returns a ref with the chain."
  (fn [chain-name]
    (send-prelude! chain-name)
    (send-code! chain-name "rad/chains/issue-remote.rad")
    (ref (new-chain chain-name))))

(def new-issue!
  "Create a new remote issue. Takes a chain ref, a keypair, an issue title and an issue body."
  (fn [chain-ref keys title body]
   (def chain (read-ref chain-ref))
   (def id (uuid!))
   (def msg
        (string-append (lookup :url chain)
                       id
                       title
                       body))
   (def arg
        {:id        id
         :author    (lookup :public-key keys)
         :title     title
         :body      body
         :signature (gen-signature! (lookup :private-key keys) msg)})
   (send! (lookup :url chain)
          [(list 'create-issue arg)])))

(def list-issues
  "Given an issues ref `x`, returns its issues. Does not itself update the chain."
  (fn [chain-ref]
    (lookup :result (eval-in-chain '(list-issues) (read-ref chain-ref)))))

(def import-issues-github
  (fn [chain-ref file]
    (def is (read (read-file! file)))
    (map (fn [i] (new-issue! chain-ref keys _ _)) is)
    ))

(:test
  "creating, manipulating and querying issue chains"
  [:setup
     (do
       (def pk (gen-key-pair! (default-ecc-curve)))
       (def chain-name (uuid!))
       (def chain-ref (create-issues-chain! chain-name))
       (new-issue! chain-ref pk "Ah!" "if thou issueless shall hap to die")
       (update-chain-ref chain-ref)
       (def issues (values (list-issues chain-ref))))
   ]
   [ (length issues) ==> 1 ]
   [ (lookup :title (nth 0 issues)) ==> "Ah!" ]
   [ (lookup :body (nth 0 issues)) ==> "if thou issueless shall hap to die" ]
)
