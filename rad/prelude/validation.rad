{:module 'prelude/validation
 :doc "Functions for creating or combining *validators*, which are functions which return the input unchanged or throw with an error message. These can be used for checking data before accepting it onto a chain."
 :exports ['= 'member 'and 'or 'type 'pred 'key 'keys 'every 'uuid 'signed]}

(import prelude/dict)

(def =
  "Given `x`, returns a validator that checks for equality with `x`."
  (fn [x]
    (fn [y]
      (if (eq? x y)
        x
        (throw 'validation-failure (string-append "Not equal to: " (show x)))))))

(def member
  "Given a structure, returns a validator which checks for membership in the structure."
  (fn [xs]
    (fn [x]
      (if (member? x xs)
        x
        (throw 'validation-failure (string-append "Not a member of: " (show xs)))))))

(def and
  "Given a sequence of validators `vs`, returns a new validator which, given a
  value, checks if it conforms to all the validators in `vs`."
  (fn [vs]
    (fn [x]
      (map (fn [v] (v x)) vs)
      x)))

(def-rec or
  "Given a vector of validators `vs`, returns a new validator which, given a
  value, checks if it conforms to at least one of the `vs`."
  (fn [vs]
    (fn [x]
      (if (eq? vs [])
        (throw 'validation-failure "validation/or: didn't satisfy any of the validators")
        (catch
          'validation-failure
          ((nth 0 vs) x)
          (fn [y] ((or (drop 1 vs)) x)))))))

(def type
  "Checks that a value has a type. Expects a keyword describing the type, as
  returned by the `type` function."
  (fn [t]
    (fn [x]
      (if (eq? (type x) t)
        x
        (throw 'validation-failure (string-append "Did not have type " (show t) ": " (show x)))))))

(def pred
  "Given a description and a predicate, returns a validator that checks if the
  predicate is true."
  (fn [name p]
    (fn [x]
      (if (p x)
        x
        (throw 'validation-failure (string-append "Did not satisfy predicate: " name))))))

(def key
  "Given a key and a validator, returns a validator which checks for
  the existence of that key and that the associated value conforms to the validator."
  (fn [k v]
    (fn [d]
      (if (member? k d)
        (v (lookup k d))
        (throw 'validation-failure (string-append "Missing required key: " (show k)))))))

(def keys
  "Given a dict associating keys to validators, returns a validator which checks a dict
  for the existence of those keys, and that they conform to the associated validators."
  (fn [ks]
    (fn [d]
      (if (dict? d)
        ((and
          (map (fn [kv] (key (nth 0 kv) (nth 1 kv)))
               (seq ks)))
         d)
        (throw 'validation-failure (string-append "Not a dict: " (show d)))))))

(def every
  "Given a validator, creates a new validator which checks that all the items in
  a sequence conform to it."
  (fn [v]
    (fn [xs]
      (map v xs))))

(def uuid
  "Validates UUIDs."
  (and
   [(type :string)
    (pred "valid UUID" uuid?)]))

(def signed
  "Checks that a value is a dict with `:signature` and `:author` keys, and that
  the signature is valid for the rest of the dict for that author. The rest of
  the dict is turned into a string according to `show`."
  (and
   [(keys
     {:author (pred "valid public key" public-key?)})
    (pred
     "Valid signature"
     (fn [d]
       (verify-signature
        (lookup :author d)
        (lookup :signature d)
        (show (delete-many [:author :signature] d)))))]))

(:test "signed"
  [:setup
   (do (def keys (gen-key-pair! (default-ecc-curve)))
       (def sk (lookup :private-key keys))
       (def pk (lookup :public-key keys))
       (def payload
         {:nonce (uuid!)
          :some "data"})
       (def payload_ (insert :some "datadata" payload))
       (def sig  (gen-signature! sk (show payload)))
       (def seal {:author    (lookup :public-key keys)
                  :signature sig})
       (def full (<> payload seal))
       (def full_ (<> payload_ seal))
       (def ok
         (catch 'any (do (signed full) :ok) (fn [x] :not-ok)))
       )
   ]
  [ ok ==> :ok ]
)
