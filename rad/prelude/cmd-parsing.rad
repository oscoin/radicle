{:module 'prelude/cmd-parsing
 :doc "Functions for parsing commands."
 :exports
 '[parse-failure /cmd-0 /cmd-1 /cmd-2 /cmd-opts]}

(import prelude/basic :unqualified)
(import prelude/dict :unqualified)
(import prelude/validation :as 'validation)
(import prelude/patterns :unqualified)
(import prelude/lens :unqualified)
(import prelude/seq :unqualified)

(def parse-failure-mode (ref {:stub #f}))

(def parse-failure
  "Prints the passed error message and help text and exits."
  (fn [error help]
    (if (lookup :stub (read-ref parse-failure-mode))
      (string-append error " " help)
      (do
        (put-str! error)
        (put-str! help)
        (exit! 1)))))

(def missing-arg-error
  (fn [arg cmd]
    (string-append "Missing argument \"" (show arg) "\" for command \"" cmd "\"")))

(def too-many-args-error
  (fn [cmd]
    (string-append "Too many arguments for command \"" cmd "\"")))

(def /cmd-opts
  "Matches the command `cmd` and a combination of optional parameters, where
  `opt-match` matches the options to the keys of `multi-ops`. `multi-ops` is a
  dict of option-keys with multiple arguments. If no options are passed, the
  `default` is returned."
  (fn [cmd opts cmd-opts help]
    (def default
      (dict-from-seq
        (map (fn [opt] (list (lookup :key opt) (lookup :default opt))) cmd-opts)))
    (def-rec parse-cli
      (fn [args]
        (def parse-arg
          (fn [opt args]
            (def opt-key (lookup :key opt))
            (match args
              (/cons 'val 'rest)
                  (if (elem? val (lookup :possible-values opt))
                    (modify-map opt-key (fn [x] (cons val x)) (parse-cli rest))
                    (parse-failure (string-append "Invalid argument " val " for option " (show opt-key) ".") help))
              []  (parse-failure (string-append "Missing argument for option " (show opt-key) ".") help)
              )))
        (def parse-opt
          (fn [opt rest]
            (def option
              (match (filter (fn [x] (elem? opt (lookup :options x))) cmd-opts)
                []    (parse-failure (string-append "Invalid option " opt " for command list.") help)
                'filt (first filt)))
            (if (eq? (lookup :type option) :flag)
              (insert (lookup :key option) #t (parse-cli rest))
              (parse-arg option rest))))
        (match args
          /nil                default
          (/cons 'opt 'rest)  (parse-opt opt rest))))
    (fn [v]
      (match v
        [cmd]           [:just {opts default}]
        (/cons cmd 'os) [:just {opts (parse-cli os)}]
        _               :nothing))))

(:test "/cmd-opts"
  [:setup
    (do
      (def help "help")
      (def cmd-opts
        [
          { :key :state :type :multi-opt :options ["-s" "--state" "--filter-by-state"] :possible-values ["acc" "prop"] :default []}
          { :key :fancy :type :flag :options ["--fancy"] :default #f }
        ])
      (def /cmd (/cmd-opts "list" 'opts cmd-opts help)))]
  [(/cmd ["list"] ) ==> [:just {opts {:state [] :fancy #f}}]]
  [(/cmd ["list" "--fancy"] ) ==> [:just {opts {:state [] :fancy #t}}]]
  [(/cmd ["list" "--state" "acc"] ) ==> [:just {opts {:state ["acc"] :fancy #f}}]]
  [(/cmd ["list" "--fancy" "-s" "acc"] ) ==> [:just {opts {:state ["acc"] :fancy #t}}]]
  [(/cmd ["list" "--state" "prop" "-s" "acc"] ) ==> [:just {opts {:state ["prop" "acc"] :fancy #f}}]])

(def /cmd-2
  "Matches a command `cmd` with exactly two arguments."
  (fn [cmd arg-1 arg-2 help]
    ((validation/type :string) cmd)
    ((validation/type :atom) arg-1)
    ((validation/type :atom) arg-2)
    (fn [value]
      (match value
        [cmd 'a-1 'a-2] (match-pat [arg-1 arg-2] [a-1 a-2])
        [cmd _] (parse-failure (missing-arg-error arg-2 cmd) help)
        [cmd] (parse-failure (missing-arg-error arg-1 cmd) help)
        (/cons cmd _) (parse-failure (too-many-args-error cmd) help)
        _ :nothing))))

(:test "/cmd-2"
  [:setup
   (do (set-ref parse-failure-mode (@ :stub) #t))]
  [ ((/cmd-2 "cmd-2" 'arg-1 'arg-2 "help") ["cmd-2" "arg1" "arg2"]) ==> [:just {arg-1 "arg1" arg-2 "arg2"}]]
  [ ((/cmd-2 "cmd-2" 'arg-1 'arg-2 "help") ["cmd-0"]) ==> :nothing]
  [ ((/cmd-2 "cmd-2" 'arg-1 'arg-2 "help") ["cmd-2"]) ==> "Missing argument \"arg-1\" for command \"cmd-2\" help"]
  [ ((/cmd-2 "cmd-2" 'arg-1 'arg-2 "help") ["cmd-2" 1]) ==> "Missing argument \"arg-2\" for command \"cmd-2\" help"]
  [ ((/cmd-2 "cmd-2" 'arg-1 'arg-2 "help") ["cmd-2" 1 2 3]) ==> "Too many arguments for command \"cmd-2\" help"])

(def /cmd-1
  "Matches a command `cmd` with exactly one arguments."
  (fn [cmd cmd-args-pat help]
    ((validation/type :string) cmd)
    ((validation/type :atom) cmd-args-pat)
    (fn [value]
      (match value
        [cmd 'cmd-args] (match-pat cmd-args-pat cmd-args)
        [cmd] (parse-failure (missing-arg-error cmd-args-pat cmd) help)
        (/cons cmd _) (parse-failure (too-many-args-error cmd) help)
        _ :nothing))))

(:test "/cmd-1"
  [:setup
   (do (set-ref parse-failure-mode (@ :stub) #t))]
  [ ((/cmd-1 "cmd-1" 'arg "help") ["cmd-1" "arg"]) ==> [:just {arg "arg"}]]
  [ ((/cmd-1 "cmd-1" 'arg "help") ["cmd-0"]) ==> :nothing]
  [ ((/cmd-1 "cmd-1" 'arg "help") ["cmd-1"]) ==> "Missing argument \"arg\" for command \"cmd-1\" help"]
  [ ((/cmd-1 "cmd-1" 'arg "help") ["cmd-1" 1 2]) ==> "Too many arguments for command \"cmd-1\" help"])

(def /cmd-0
  "Matches a command `cmd` with no other arguments."
  (fn [cmd help]
    ((validation/type :string) cmd)
    (fn [value]
     (match value
       [cmd] [:just {}]
       (/cons cmd _) (parse-failure (too-many-args-error cmd) help)
       _ :nothing))))

(:test "/cmd-0"
  [:setup
    (do (set-ref parse-failure-mode (@ :stub) #t))]
  [ ((/cmd-0 "cmd-0" "help") ["cmd-0"]) ==> [:just {}]]
  [ ((/cmd-0 "cmd-0" "help") ["cmd-1"]) ==> :nothing]
  [ ((/cmd-0 "cmd-0" "help") ["cmd-0" 1]) ==> "Too many arguments for command \"cmd-0\" help"])
