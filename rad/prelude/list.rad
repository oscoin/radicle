{:module 'prelude/list
 :doc "Functions for manipulating lists."
 :exports ['nil 'empty? 'reverse 'range 'concat 'filter 'take-while]}

;; nil

(import prelude/basic :unqualified)
(import prelude/bool :unqualified)

(def nil "The empty list." (list))

;; empty?

(def empty?
  "True if `seq` is empty, false otherwise."
  (fn [seq] (or (eq? seq nil) (eq? seq []))))

(:test "empty"
  [ (empty? (list 2)) ==> #f ]
  [ (empty? [2]) ==> #f ]
  [ (empty? []) ==> #t ]
)

;; reverse

(def reverse
  "Returns the reversed list `ls`."
  (fn [ls]
    (def-rec go
      (fn [acc new]
        (if (empty? new)
            acc
            (go (cons (head new) acc) (tail new)))))
    (go (list) ls)))

(:test "reverse"
  [ (reverse (list 1 2 3)) ==> (3 2 1) ]
)

;; range

(def-rec range
  "Returns a list with all integers from `from` to `to`, inclusive."
  (fn [from to]
    (if (eq? from to)
        (list to)
        (cons from (range (+ 1 from) to)))))

(:test "range"
  [ (range 1 5) ==> (1 2 3 4 5) ]
)

;; concat

(def concat
  "Concatenates `list1` and `list2`."
  (fn [list1 list2]
    (foldr (fn [a b] (cons a b)) list2 list1)))

(:test "concat"
  [ (concat '(1 2 3) '(4 5 6)) ==> (1 2 3 4 5 6) ]
)

;; filter

(def-rec filter
  "Returns `ls` with only the elements that satisfy `pred`."
    (fn [pred ls]
      (cond
        (empty? ls)      ls
        (pred (head ls)) (cons (head ls) (filter pred (tail ls)))
        :else            (filter pred (tail ls)))))

(:test "filter"
  [ (filter (fn [x] (< x 10)) (list 3 10 11 5))
     ==> (3 5) ]
  [ (filter (fn [x] (< x 10)) [3 10 11 5])
     ==> [3 5] ]
)

;; take-while

(def-rec take-while
  "Returns all elements of a sequence `ls` until one does not satisfy `pred`"
  (fn [pred ls]
    (cond
      (empty? ls)       ls
      (pred (head ls))  (cons (head ls) (take-while pred (tail ls)))
      :else             (if (list? ls)
                          (list)
                          []))))

(:test "take-while"
  [ (take-while (fn [x] (eq? x "bar")) (list "foo" "bar") ) ==> () ]
  [ (take-while (fn [x] (not (eq? x "bar"))) (list "foo" "bar") ) ==> ("foo") ]
  [ (take-while (fn [x] (< x 10)) [3 9 10 11] ) ==> [3 9] ])
