'prelude/list

"Functions for manipulating lists."

['nil 'empty? 'reverse 'range 'concat 'filter]

;; List functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; nil

(import prelude/basic)
(import prelude/recursion ['Y2])

(def nil "The empty list." (list))

;; empty?

(def empty?
  "True if 'seq' is empty, false otherwise."
  (fn [ls] (or (eq? ls nil) (eq? ls []))))

(:test "empty"
  [ (empty? (list 2)) ==> #f ]
  [ (empty? [2]) ==> #f ]
  [ (empty? []) ==> #t ]
)

;; reverse

(def reverse
  "Returns the reversed 'ls'."
  (fn [ls]
    (def-rec go
      (fn [acc new]
        (if (empty? new)
            acc
            (go (cons (head new) acc) (tail new)))))
    (go (list) ls)))

(:test "reverse"
  [ (reverse (list 1 2 3)) ==> (3 2 1) ]
)

;; range

(def-rec range
  "Returns a list with all integers from `from` to `end`, inclusive."
  (fn [from to]
    (if (eq? from to)
        (list to)
        (cons from (range (+ 1 from) to)))))

(:test "range"
  [ (range 1 5) ==> (1 2 3 4 5) ]
)

;; concat

(def concat
  "Concatenates 'list1' and 'list2'."
  (fn [list1 list2]
    (foldr (fn [a b] (cons a b)) list2 list1)))

(:test "concat"
  [ (concat '(1 2 3) '(4 5 6)) ==> (1 2 3 4 5 6) ]
)

;; filter

(def-rec filter
  "Returns 'list' with only the elements that satisfy 'filter-cond'."
    (fn [pred ls]
      (cond
        (empty? ls)      ls
        (pred (head ls)) (cons (head ls) (filter pred (tail ls)))
        :else            (filter pred (tail ls)))))

(:test "filter"
  [ (filter (fn [x] (< x 10)) (list 3 10 11))
     ==> (3) ]
)
