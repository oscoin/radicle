{:module 'prelude/test-eval
 :doc
 "Provides eval that adds a `test` macro. If an the eval encounters an
   expression of the form `(test \"desc\" tests...)` we add it to the vector
   stored in the `tests` ref. The tests are then run by `rad/prelude/test.rad`."
 :exports '[test tests]}

(def tests
  "Reference that collects tests defined with the `test` macro. This
  value is updated by a custom `eval`."
  (ref []))

(def test
  (macro
   (fn es
     (list
      'do
      (list
       write-ref
       tests
       (list
        add-right
        {:doc-test (list 'quote (drop 1 es))
         :name     (nth 0 es)
         :env      (list get-current-state)}
        (list read-ref tests)))
      :test-added))))

;; ;; Annoyingly verbose since we have neither the prelude nor pattern-matching.
;; (def tx
;;   "Transaction function that adds test macro to register tests."
;;   (fn [expr state]
;;     (if (list? expr)
;;       (if (> (length expr) 0)
;;         (if (eq? (first expr) 'test)
;;           (do ;; (put-str! (nth 1 expr))
;;               (def next-tests {:doc-test (drop 2 expr) :name (nth 1 expr) :env state})
;;               (write-ref tests (add-right next-tests (read-ref tests)))
;;               :test-added)
;;           (tx expr state))
;;         (tx expr state))
;;       (tx expr state))))

(test "'test' works (including :setup)"
    [:setup
       (do
          (def x 3)
          (def y (ref 0))
          (write-ref y 1))
    ]
    [(+ 3 2) ==> 5]
    [x       ==> 3]
)

(test "'test' handles exceptions properly"
    [:setup
      (do
        (def x (catch 'any (throw 'blah) (fn [x] #t)))
        (def y (catch 'any (throw 'blah) (fn [x] #f)))
      )
    ]
    [x ==> #t]
    [y ==> #f]
)
