{:module 'prelude/machine
 :doc "Functions for simulating remote machines."
 :exports '[new-machine load-machine! eval-in-machine update-machine-ref! eval
            updatable-eval update-machine! eval-fn-app send-prelude!
            send-code! send! receive! install-remote-machine-fake]}

(import prelude/io '[read-file-values!] :as 'io)
(import prelude/ref '[modify-ref] :unqualified)
(import prelude/lens '[make-lens .. ... view set over @ @def] :unqualified)
(import prelude/basic :unqualified)
(import prelude/io :unqualified)
(import prelude/patterns :unqualified)
(import prelude/strings :unqualified)
(import prelude/seq :unqualified)

(def base-send!
  "See documentation of `send!`"
  (fn [id inputs]
    (match id
      (/prefix "ipfs://" 'rest) (machine/ipfs/update! rest inputs)
      (/prefix "http://" _) (machine/eval-server/update! id inputs)
      _ (throw 'unknown-machine-type (string-append "Cannot handle machine ID " id)))
  ))

(def primitive-stub-ref/send! (ref base-send!))
(def send!
  "Update a machine with the vector of `inputs` to evaluate. Returns an
  index that identifies that last input. This index can be passed to
  `receive!`"
  (fn [machine-id inputs] ((read-ref primitive-stub-ref/send!) machine-id inputs)))

(def base-receive!
  "See documentation of `receive!`"
  (fn [id index]
    (match id
      (/prefix "ipfs://" 'rest) (machine/ipfs/get-log! rest index)
      (/prefix "http://" _) (machine/eval-server/get-log! id index)
      _ (throw 'unknown-machine-type (string-append "Cannot handle machine ID " id)))
  ))

(def primitive-stub-ref/receive! (ref base-receive!))
(def receive!
  "Get inputs from a machine. Returns a `[index inputs]` pair where
  `inputs` is a vector of expressions and `index` is the index of the
  last input in `inputs`. The `index` argument is either `:nothing` in
  which case all inputs are fetched or `[:just i]` in which case all
  inputs following after the index `i` are fetched."
  (fn [machine-id index] ((read-ref primitive-stub-ref/receive!) machine-id index)))


(def env-var
  "A lens for variables in envs."
  (fn [i]
    (make-lens (fn [e] (get-binding i e))
               (fn [v e] (set-binding i v e)))))

(def @env
  "A lens for env part of a machine state."
  (make-lens state->env set-env))

(def @var
  "A lens for variables in machine states."
  (fn [i]
    (.. @env (env-var i))))

(def new-machine
  "Return an empty machine dictionary with the given url."
  (fn [url]
    {:state (pure-state)
     :inputs []
     :url url
     :index :nothing}))

;; eval-in-machine

(def eval-in-machine
  "Evaluates `expr` in the `machine` and returns a dict with the `:result` and the resulting `:machine`."
  (fn [expr machine]
    (def machine-eval (view (.. (@ :state) (@var 'eval)) machine))
    (def x (machine-eval expr (lookup :state machine)))
    (def result (nth 0 x))
    (def new-state (nth 1 x))
    (def new-machine
      (insert
        :state
        new-state
        (over (@ :inputs)
              (fn [inputs] (add-right expr inputs))
               machine)))
    {:machine new-machine
     :result result }))

(:test "eval-in-machine"
  [:setup
    (do (def empty-machine (new-machine (uuid!)))
        (def res1 (eval-in-machine '(def x 3) empty-machine))
        (def res (eval-in-machine '(+ x 2) (lookup :machine res1))))
  ]
  [ (view (@ :result) res)                 ==> 5                   ]
  [ (view (.. (@ :machine) (@ :inputs)) res) ==> [(def x 3) (+ x 2)] ]
)

;; update-machine!

(def update-machine!
  "Takes a machine, and returns a new machine updated with the new expressions from the remote machine"
  (fn [machine]
    (def index (length (lookup :inputs machine)))
    (def receive-result
      (receive! (lookup :url machine) (lookup :index machine)))
    (def new-index (nth 0 receive-result))
    (def new-inputs (nth 1 receive-result))
    (def upd-ch
      (fn [ch expr]
        (def x (eval-in-machine expr ch))
        (view (@ :machine) x)))
    (def machine (foldl upd-ch machine new-inputs))
    (insert :index [:just new-index] machine)))

(def install-remote-machine-fake
  "Install test doubles for the `send!` and `receive!` primitives that
  use a mutable dictionary to store RSMs. Requires
  `rad/test/stub-primitives` to be loaded"
  (fn []
      (def remote-machines (ref {}))

      (write-ref primitive-stub-ref/send!
        (fn [name exprs]
          (modify-ref remote-machines
            (fn [machines] (over (@def name []) (fn [machine-exprs] (<> machine-exprs exprs)) machines)))))

      (write-ref primitive-stub-ref/receive!
        (fn [name maybeIndex]
          (def inputs (lookup name (read-ref remote-machines)))
          (def index
            (match maybeIndex
              (/just 'index) (+ index 1)
              :nothing 0))
          [(length inputs) (drop index inputs)]))
  ))
(:test "update-machine!"
  [:setup
    (do
       (install-remote-machine-fake)
       (def machine-name (uuid!))
       (def machine (new-machine machine-name))
       (send! machine-name ['(+ 3 2)])
       (send! machine-name ['(+ 3 3)])
       (def machine (update-machine! machine)))
  ]
  [ (lookup :inputs machine) ==> [(+ 3 2) (+ 3 3)]]
)

(def load-machine!
  "Takes a `url`, and fetches the inputs of a remote machine and return a machine dictionary with the machine state."
  (fn [url]
    (update-machine! (new-machine url))))

;; update-machine-ref!

(def update-machine-ref!
  "Update `machine-ref` containing a machine with the new expressions from the remote machine"
  (fn [machine-ref]
    (modify-ref machine-ref update-machine!)
    :ok))

(:test "update-machine-ref!"
  [:setup
    (do
       (install-remote-machine-fake)
       (def machine-name (uuid!))
       (def machine (ref (new-machine machine-name)))
       (send! machine-name ['(+ 3 2)])
       (send! machine-name ['(+ 3 3)])
       (update-machine-ref! machine))
  ]
  [ (lookup :inputs (read-ref machine)) ==> [(+ 3 2) (+ 3 3)]]
)

;; add-quit

(def add-quit
  "Adds a `:quit` command to `before-quit-eval`, which switches to `after-quit-state` (and to the eval in that state)"
  (fn [after-quit-state before-quit-eval]
    (fn [expr env]
      (if (eq? expr :quit)
          (list :ok after-quit-state)
          (before-quit-eval expr env)))))

;; store-exprs

(def store-exprs
  "Store each new evaluated expression in `_inputs`"
 (fn [evalfn]
     (fn [expr env]
         (def env_ (over (@var '_inputs) (fn [x] (add-right expr x)) env))
         (evalfn expr env_ ))))

;; enter-remote-machine!
(def enter-remote-machine!
  "Make the eval behave as that of a remote machine. The second param is the env to return to after `:quit`."
  (fn [url env]
    (def machine (load-machine! url))
    (def machine-state (lookup :state machine))
    (def mod-state1 (set (@var '_inputs) [] machine-state))
    (def mod-state2 (set (@var '_cur-machine) (lookup :url machine) mod-state1))
    (def mod-state3 (over (@var 'eval)
                          (fn [x] (add-quit env x))
                          mod-state2))
    (list :ok mod-state3)))

(def eval__ "The eval in place when `machine.rad` is loaded." eval)

(def eval
  "An eval in which one can use `(:enter-machine url)` to make the
  eval behave as that of a remote machine, and `:send` to send all
  enqueued expressions."
  (fn [expr env]
      (if (list? expr)
          (cond
            (eq? (first expr) :enter-machine)
              (enter-remote-machine! (first (eval__ (nth 1 expr) env)) env)
            :else (eval__ expr env))
          (eval__ expr env))))

(def eval-fn-app
  "Given a state, a function, an argument and a callback, returns
  the result of evaluating the function call on the arg in the given
  state, while also calling the callback on the result."
  (fn [state f arg cb]
    (def exec (base-eval (list f (list 'quote arg)) state))
    (cb (first exec))
    exec))

(def updatable-eval
  "Given an evaluation function `f`, returns a new one which augments `f` with a new
  command `(update expr)` which evaluates arbitrary expression using `base-eval`."
  (fn [sub-eval]
    (fn [expr state]
      (match expr
             (/cons 'cmd _) (if (eq? cmd 'update)
                              (base-eval (nth 1 expr) state)
                              (sub-eval expr state))
             _ (sub-eval expr state)))))

(def pure-prelude-files
  "List of files which together define the pure prelude."
  ["rad/prelude/basic.rad"
   "rad/prelude/patterns.rad"
   "rad/prelude/strings.rad"
   "rad/prelude/dict.rad"
   "rad/prelude/bool.rad"
   "rad/prelude/maybe.rad"
   "rad/prelude/list.rad"
   "rad/prelude/set.rad"
   "rad/prelude/ref.rad"
   "rad/prelude/lens.rad"
   "rad/prelude/state-machine.rad"
   "rad/prelude/validation.rad"
   "rad/prelude/util.rad"])

(def file-to-module
  "Make the text of a file into code for a module."
  (fn [file]
    (cons 'module (vec-to-list (io/read-file-values! file)))))

(def pure-prelude-code
  "Code for the pure prelude. Useful as the first inputs to a new machine."
  (<> [(file-to-module "rad/prelude/test-eval.rad")
       '(import prelude/test-eval '[eval tests] :unqualified)]
      (map file-to-module pure-prelude-files)))

(def send-prelude!
  "Send the pure prelude to a machine."
  (fn [machine-id]
    (send! machine-id pure-prelude-code)))

(def send-code!
  "Send code from a file to a remote machine."
  (fn [machine-id filename]
    (send! machine-id (io/read-file-values! filename))))
