{:module 'prelude/error-messages
 :doc "Functions for user facing error messages.
 Functions should either have a descriptive name or additional comment so that
 the text can be edited without knowledge of where they are used.
 To verify changes, tests can be run with `stack exec -- radicle test/all.rad`"
 :exports
 '[missing-arg too-many-args missing-arg-for-opt invalid-arg-for-opt
   invalid-opt-for-cmd dir-already-exists git-clone-failure upstream-commit-failure
   upstream-push-failure item-not-found whole-item-number missing-item-number
   state-change-failure no-number-returned unknown-command unknown-commit
   checkout-new-branch-failure checkout-master-failure applying-patch-failure
   applying-accepted-patch-failure push-diff-failure missing-key-file]}

(import prelude/strings :unqualified)

;; parsing

(def missing-arg
  (fn [arg cmd]
    (string-append "Missing argument \"" arg "\" for command \"" cmd "\"")))

(:test "missing-arg"
  [(missing-arg "foo" "bar") ==> "Missing argument \"foo\" for command \"bar\""])

(def too-many-args
  (fn [cmd]
    (string-append "Too many arguments for command \"" cmd "\"")))

(:test "too-many-args"
  [(too-many-args "foobar") ==> "Too many arguments for command \"foobar\""])

(def valid-args-help
  (fn [args]
    (string-append "Valid arguments: " (intercalate ", " args))))

(:test "valid-args-help"
  [(valid-args-help ["foo" "bar"]) ==> "Valid arguments: foo, bar"])

(def missing-arg-for-opt
  (fn [opt valid-args]
    (string-append
      "Missing argument for option \"" opt "\". "
      (valid-args-help valid-args))))

(:test "missing-arg-for-opt"
  [(missing-arg-for-opt "-s" ["foo" "bar"]) ==> "Missing argument for option \"-s\". Valid arguments: foo, bar"])

(def invalid-arg-for-opt
  (fn [arg opt valid-args]
    (string-append
      "Invalid argument \"" arg "\" for option \"" opt "\". "
      (valid-args-help valid-args))))

(:test "invalid-arg-for-opt"
  [(invalid-arg-for-opt "foobar" "-s" ["foo" "bar"]) ==> "Invalid argument \"foobar\" for option \"-s\". Valid arguments: foo, bar"])

(def invalid-opt-for-cmd
  (fn [opt cmd]
    (string-append "Invalid option \"" opt "\" for command " cmd ".")))

(:test "invalid-opt-for-cmd"
  [(invalid-opt-for-cmd "foo" "list") ==> "Invalid option \"foo\" for command list."])

;; unexported helpers for app errors

(def a-or-an
  (fn [word]
    (if (all (map (fn [x] (not (starts-with? word x))) ["a" "e" "i" "o" "u"]))
      "a"
      "an")))

(def uppercase-item
  (fn [item]
    (lookup item {:issue "Issue" :diff  "Diff"})))

(def lowercase-item
  (fn [item]
    (lookup item {:issue "issue" :diff  "diff"})))

;; rad project specific errors

(def dir-already-exists
  "`rad project checkout` is aborted, if there is already a directory with the name
  of the project `dir-name` in the current directory."
  (fn [dir-name]
    (string-append
      "The directory \"" dir-name "\" already exists.\n"
      "Refusing to continue.")))

(:test "dir-already-exists"
  [(dir-already-exists "foobar") ==>
    "The directory \"foobar\" already exists.
Refusing to continue."])

(def git-clone-failure
  "`rad project checkout` is aborted, if cloning the repo `name` form `origin` failed."
  (fn [origin name]
    (string-append
      "The repo is currently not available. "
      "Cloning \"" name "\" from \"" origin "\" failed.\n"
      "This may be because you have no internet connection, "
      "or the IPNS link is stale, or because no online node "
      "with the data could be found.")))

(:test "git-clone-failure"
  [(git-clone-failure "foo" "bar") ==>
    "The repo is currently not available. Cloning \"bar\" from \"foo\" failed.
This may be because you have no internet connection, or the IPNS link is stale, or because no online node with the data could be found."])

(def upstream-commit-failure
  "`rad project init` is aborted when creating an empty commit failed in
  preparation to setting the upstream master branch."
  (fn []
    (string-append
      "Error: git commit --allow-empty --message \"Radicle Setup\" failed.\n"
      "Make sure that git was initialized correctly and rerun 'rad project init'")))

(:test "upstream-commit-failure"
  [(upstream-commit-failure) ==> "Error: git commit --allow-empty --message \"Radicle Setup\" failed.
Make sure that git was initialized correctly and rerun 'rad project init'"])

(def upstream-push-failure
  "`rad project init` is aborted when pushing the empty commit failed while setting
  the upstream master branch."
  (fn []
    (string-append
      "Error: git -u origin master failed.\n"
      "Set the upstream branch manually and rerun 'rad project init'")))

(:test "upstream-push-failure"
  [(upstream-push-failure) ==> "Error: git -u origin master failed.
Set the upstream branch manually and rerun 'rad project init'"])

;; rad diff specific errors

(def unknown-commit
  "`rad diff propose` aborts if the provided commit is unknown."
  (fn [commit]
    (string-append
      "Commit " commit " can't be found.")))

(:test "unknown-commit"
  [(unknown-commit "12345") ==> "Commit 12345 can't be found."])

(def checkout-new-branch-failure
  "`rad diff checkout` aborts if creating and switching to the diff branch fails."
  (fn [branch]
    (string-append "Creating and switching to branch " branch " failed.")))

(:test "checkout-new-branch-failure"
  [(checkout-new-branch-failure "diff/3") ==> "Creating and switching to branch diff/3 failed."])

(def checkout-master-failure
  "`rad diff accept` aborts if checking out the master branch fails."
  (fn []
    (string-append
      "Checkout branch master failed.\n"
      "Refusing to continue.")))

(:test "checkout-master-failure"
  [(checkout-master-failure) ==> "Checkout branch master failed.
Refusing to continue."])

(def applying-patch-failure
  "`rad diff checkout` aborts if applying the patch to the diff branch fails.
  Conflicts have to be resolved manually."
  (fn []
    (string-append
      "Applying the patch failed.\n"
      "Abort or resolve any conflicts via 'git am'.")))

(:test "applying-patch-failure"
  [(applying-patch-failure) ==> "Applying the patch failed.
Abort or resolve any conflicts via 'git am'."])

(def applying-accepted-patch-failure
  "`rad diff accept` aborts if applying the patch to master fails.
  Conflicts have to be resolved manually as well as pushing the commit."
  (fn []
    (string-append
      (applying-patch-failure) "\n"
      "Then run 'git push'.")))

(:test "applying-accepted-patch-failure"
  [(applying-accepted-patch-failure) ==> "Applying the patch failed.
Abort or resolve any conflicts via 'git am'.
Then run 'git push'."])

(def push-diff-failure
  "`rad diff accept` aborts if pushing the diff failed."
  (fn []
    (string-append
      "Pushing the diff failed.\n"
      "This may be because you have no internet connection, "
      "you are not authorized to push to origin, "
      "or the remote is currently not reachable.")))

(:test "push-diff-failure"
  [(push-diff-failure) ==> "Pushing the diff failed.
This may be because you have no internet connection, you are not authorized to push to origin, or the remote is currently not reachable."])

;; shared app errors

(def item-not-found
  "Any command on a specific diff/issue aborts if it does not exist."
  (fn [item item-number]
    (string-append (uppercase-item item) " #" item-number " does not exist.")))

(:test "item-not-found"
  [(item-not-found :diff "2") ==> "Diff #2 does not exist."]
  [(item-not-found :issue "3") ==> "Issue #3 does not exist."])

(def whole-item-number
  "Any command on a specific diff/issue aborts if the provided `item-number`
  is not a whole number."
  (fn [item]
    (string-append (uppercase-item item) " numbers must be whole numbers!")))

(:test "whole-item-number"
  [(whole-item-number :diff) ==> "Diff numbers must be whole numbers!"]
  [(whole-item-number :issue) ==> "Issue numbers must be whole numbers!"])

(def missing-item-number
  "Any command on a specific diff/issue aborts if the `item-number` is not provided."
  (fn [item action]
    (def item-name (lowercase-item item))
    (string-append
      "To " action " " (a-or-an item-name) " " item-name
      ", please provide the " item-name " number.")))

(:test "missing-item-number"
  [(missing-item-number :diff "change the state of") ==> "To change the state of a diff, please provide the diff number."]
  [(missing-item-number :issue "show") ==> "To show an issue, please provide the issue number."])

(def state-change-failure
  "On changing the state of a diff/issue if the daemon returned an error."
  (fn [item state]
    (string-append
      (uppercase-item item) " could not be " state ". "
      "Are you authorized to do so?")))

(:test "state-change-failure"
  [(state-change-failure :diff "rejected") ==> "Diff could not be rejected. Are you authorized to do so?"]
  [(state-change-failure :issue "closed") ==> "Issue could not be closed. Are you authorized to do so?"])

(def no-number-returned
  "On creating a diff/issue, when the creation was successful,
  but no diff/issue number was returned."
  (fn [item]
    (string-append (uppercase-item item) " created but unexpected results returned.")))

(:test "no-number-returned"
  [(no-number-returned :diff) ==> "Diff created but unexpected results returned."]
  [(no-number-returned :issue) ==> "Issue created but unexpected results returned."])

(def unknown-command
  "An unknown command for an app. E.g. `rad issue foobar`"
  (fn [cmd]
    (string-append "Unknown command: " cmd)))

(:test "unknown-command"
  [(unknown-command "foo") ==> "Unknown command: foo"])

;; key management

(def missing-key-file
  "Any request to the machine is aborted, when the key file can't be found."
  (fn []
    (string-append
      "Missing file: my-keys.rad\n"
      "Do `rad create-keys` to create your own key pair and rerun your command.")))

(:test "missing-key-file"
  [(missing-key-file) ==> "Missing file: my-keys.rad
Do `rad create-keys` to create your own key pair and rerun your command."])
