'prelude/basic

"Basic functions which need to be defined early because they are so useful for
other core modules."

'[or some empty-seq? length maybe->>= maybe-foldlM]

;; or

(def or
  "Returns 'arg1' if 'arg1' is not #f, otherwise returns 'arg2'"
  (fn [x y]
    (if x x y)))

(:test "or"
       [ (or #t #t) ==> #t ]
       [ (or #t #f) ==> #t ]
       [ (or #f #t) ==> #t ]
       [ (or #f #f) ==> #f ]
       )

;; some

(def some
  "Checks that there is a least one truthy value in a list."
  (fn [xs] (foldr or #f xs)))

(:test "some"
       [ (some '())            ==> #f ]
       [ (some '(#t))          ==> #t ]
       [ (some '(#f))          ==> #f ]
       [ (some '(#f #f #f))    ==> #f ]
       [ (some '(#t #t #t #t)) ==> #t ]
       [ (some '(#t #t #f #t)) ==> #t ]
       )

(def empty-seq?
  "Returns true if the input is an empty sequence (either list or vector)."
  (fn [xs]
    (or (eq? xs (list))
        (eq? xs []))))

;; length

(def length
  "Returns the length of 'list'."
  (fn [xs]
    (foldr (fn [x acc] (+ acc 1)) 0 xs)))

(:test "length"
  [ (length (list)) ==> 0]
  [ (length (list 2)) ==> 1]
)

(def maybe->>=
  "Monadic bind for the maybe monad."
  (fn [v f]
    (if (vector? v)
      (if (eq? (length v) 2)
        (if (eq? (nth 0 v) :just)
          (f (nth 1 v))
          :nothing)
        :nothing)
      :nothing)))

(def-rec maybe-foldlM
  "Monadic fold over the elements of a seq, associating to the left (i.e. from
  left to right) in the maybe monad."
  (fn [f i xs]
    (if (empty-seq? xs)
      [:just i]
      (maybe->>= (f i (nth 0 xs))
                 (fn [b] (maybe-foldlM f b (drop 1 xs)))))))
