{:module 'prelude/test
 :doc "Provides eval that adds a `:test` macro."
 :exports '[run run-all]}

(def run
  "Run the tests in `test-def` and print the result. `test-def` is a `{:env env
  :tests tests :name name}` dictionary where `env` is a radicle environment and
  `tests` is a list of quoted test cases with an optional `:setup` item.
  ```
  '(
    [:setup (do
      (def foo #t)
    )]
    [ foo ==> #t ]
    [ (not foo) ==> #f ]
  )
  ```
  "
  (fn [test-def]
    (def test-env (lookup :env test-def))
    (def test-name (lookup :name test-def))
    (def error
      (fn [msg]
        (put-str! (string-append "Test '" test-name "' failed: " msg))))
    ;; Check a single test in a given env
    (def check-single
      (fn [single ix senv]
        (def lhs (nth 0 single))
        (def marker (nth 1 single))
        (def rhs (nth 2 single))
        (if (eq? marker '==>)
            (do
              (def lhs-res (head (eval lhs senv)))
              (if (eq? lhs-res rhs)
                  (put-str! (string-append "Test '" test-name " (" (show ix) ")' succeeded"))
                  (error (string-append "failed: got " (show lhs-res) " but expected " (show rhs)))))
            (error "Expected and actual not separate by ==>"))
        (+ ix 1)))
    (def test-contents (lookup :tests test-def))
    (def maybe-setup (nth 0 test-contents))
    ;; If first block starts with :setup, run tests in that env
    (if (eq? (nth 0 maybe-setup) :setup)
        (do (def setup-env (nth 1 (eval (nth 1 maybe-setup) test-env)))
            (foldl (fn [ix x] (check-single x ix setup-env)) 1 (tail test-contents)))
        (foldl (fn [ix x] (check-single x ix test-env)) 1 test-contents))
))

(def run-all
  "Run all `tests`."
  (fn [tests]
    (map (fn [t] (run t)) tests)))
