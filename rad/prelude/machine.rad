(ns prelude/machine "Functions for simulating remote machines.")

(require prelude/test-macro ['test])
(require prelude/basic [])
(require prelude/macros '[let])
(require prelude/io '[read-file-value! read-file-values!] io)
(require prelude/ref '[modify-ref])
(require prelude/lens '[make-lens .. ... view set over @ @def])
(require prelude/basic [])
(require prelude/dict '[modify-map])
(require prelude/io [])
(require prelude/patterns '[match-pat /cons])
(require prelude/strings [])
(require prelude/seq [])
(require prelude/key-management '[get-keys!])

(defp primitive-stub-ref/send! (ref daemon/send!))
(def send!
  "Update a machine with the vector of `inputs` to evaluate. Returns a vector
  with the evaluation results."
  (fn [machine-id inputs] ((read-ref primitive-stub-ref/send!) machine-id inputs)))

(defp primitive-stub-ref/query! (ref daemon/query!))
(def query!
  "Send an expression to be evaluated on a machine. Does not alter the machine."
  (fn [machine-id expr] ((read-ref primitive-stub-ref/query!) machine-id expr)))

(defp primitive-stub-ref/new-machine! (ref daemon/new-machine!))
(def new-machine!
  "Creates a new machine. Returns the machine name."
  (fn [] ((read-ref primitive-stub-ref/new-machine!))))

(def new-fake-machine
  "An empty fake machine, which does not use the daemon"
  (pure-state))

(defp fold-in-fake-machine
  (fn [f]
    (fn [machine exprs]
      (match exprs
             [] {:machine machine :result []}
             (/cons 'e 'es)
             (let [x (f e machine)
                   new-state (nth 1 x)
                   result (nth 0 x)]
               (modify-map :result
                           (fn [i] (cons result i))
                           ((fold-in-fake-machine f) new-state es)))))))

(def eval-in-fake-machine
  "Evaluates `exprs` in the `machine` and returns a dict with the `:result` and
  the resulting `:machine`."
  (fold-in-fake-machine eval))

(def tx-in-fake-machine
  "Transacts `exprs` in the `machine` and returns a dict with the `:result` and
  the resulting `:machine`."
  (fold-in-fake-machine
   (fn [e machine]
     (let [x (eval (list 'toplevel//tx (list 'quote e))
                   machine)]
       (eval (nth 0 x) (nth 1 x))))))

(test "tx-in-fake-machine"
      [:setup
       (def res1 (tx-in-fake-machine new-fake-machine '[(def x 3)]))
       (def res (tx-in-fake-machine (lookup :machine res1) '[(+ x 2)]))
       ]
      [ (view (@ :result) res) ==> [5] ]
      )

(def install-remote-machine-fake
  "Install test doubles for the `send!`, `query!`, and `new-machine! primitives
  that use a mutable dictionary to store RSMs. Requires
  `rad/test/stub-primitives` to be loaded"
  (fn []
    (let [remote-machines (ref {})]
      
      (write-ref primitive-stub-ref/send!
                 (fn [name exprs]
                   (let [m (lookup name (read-ref remote-machines))
                         res (tx-in-fake-machine m exprs)]
                     (modify-ref remote-machines (fn [rms] (insert name (lookup :machine res) rms)))
                     (lookup :result res))))
      
      (write-ref primitive-stub-ref/query!
                 (fn [name expr]
                   (let [machine (lookup name (read-ref remote-machines))]
                     (first (lookup :result (eval-in-fake-machine machine [expr]))))))

      (write-ref primitive-stub-ref/new-machine!
                 (fn []
                   (let [name (uuid!)]
                     (modify-ref remote-machines (fn [rm] (insert name new-fake-machine rm)))
                     name))))
    ))

(def pure-prelude-files
  "List of files which together define the pure prelude."
  (map (fn [f]
         (find-rad-file! (string-append "prelude/" f ".rad")))
       ["test-macro"
        "basic"
        "macros"
        "patterns"
        "bool"
        "seq"
        "list"
        "strings"
        "dict"
        "maybe"
        "set"
        "ref"
        "lens"
        "state-machine"
        "validation"
        "nonces"
        "auth"
        "machine-remote"
        "util"]))

(def file-to-ns
  "Make the text of a file into code for a module."
  (fn [file] (io/read-file-values! file)))

(def pure-prelude-code
  "Code for the pure prelude. Useful as the first inputs to a new machine."
  (map file-to-ns pure-prelude-files))

(def send-prelude!
  "Send the pure prelude to a machine."
  (fn [machine-id]
    (send! machine-id pure-prelude-code)))

(test "install-remote-machine-fake"
      [:setup
       (do (install-remote-machine-fake)
           (def machine (new-machine!))
           (send-prelude! machine)
           (def send-result (send! machine '[(def foo 5) foo]))
           )]
      [ send-result ==> [() 5] ]
      [ (query! machine '(+ 1 foo)) ==> 6 ]
      )

(def send-code!
  "Send code from a file to a remote machine."
  (fn [machine-id filename]
    (send! machine-id (io/read-file-values! filename))))

(def sign-entity!
  "Assumes a key pair is stored at `my-keys.rad`. Using that key pair, will sign a
  dict by adding `:author` and `:signature` fields, so that it is valid
  according to `validator/signed`, while also adding a `:nonce`."
  (fn [e machine-id]
    (let [nonce (uuid!)
          e_ (<> e {:machine-id machine-id
                    :nonce      nonce})
          ks (get-keys!)
          sig (gen-signature! (lookup :private-key ks)
                              (show-unformatted e_))]
      (<> e_
          {:author    (lookup :public-key ks)
           :signature sig}))))

(def send-signed-command!
  "Send a command signed by the keys in `my-keys.rad`."
  (fn [machine machine-id cmd payload]
    (send! machine [(list cmd (sign-entity! payload machine-id))])))

(def catch-daemon!
  "Catches all `radicle-daemon` related errors and just prints them out to the
  user."
  (fn [f]
    (catch 'daemon-error (f)
      (fn [e]
        (put-str! (lookup :info e))
        (exit! 1)))))
