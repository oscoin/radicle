;; Helpers for setting up and interacting with issues chain (as defined in
;; rad/monadic/issues-remote.rad)

;; Create a remote issue chain. Returns a ref for the chain that you
;; can assign to a variable.

(load! "rad/prelude.rad")

(import prelude/lens :unqualified)

(def radicle-issues-chain-id
  "The name of this chain."
  "monadic/radicle/issues")

(def create-issues-chain!
  "Create a remote issue chain with the given url."
  (fn [url]
    (chain/send-prelude! url)
    (send-code! url "rad/monadic/issue-remote.rad")))

(def sign-entity!
  "Assumes a key pair is stored at `my-keys.rad`. Using that key pair, will sign a
  dict by adding `:author` and `:signature` fields, so that it is valid
  according to `validator/signed`, while also adding a `:nonce`."
  (fn [e]
    (def nonce (uuid!))
    (def e_ (<> e {:chain-id radicle-issues-chain-id
                   :nonce    nonce}))
    (def ks (read-file-value! "my-keys.rad"))
    (def sig
      (gen-signature! (lookup :private-key ks)
                      (show e_)))
    (<> e_
        {:author    (lookup :public-key ks)
         :signature sig})))

(def simple-issue
  "Create an open issue with no comments or labels."
  (fn [i]
    (def t (now!))
    (<> {:labels      []
         :state       :open
         :comments    []
         :created-at  t
         :modified-at t}
        i)))

(def simple-comment
  "Create a comment for an issue."
  (fn [issue-number bod]
    (def t (now!))
    {:body         bod
     :issue-number issue-number
     :created-at   t
     :modified-at  t}))

(def send-signed-command!
  "Send a command signed by the keys in `my-keys.rad`."
  (fn [chain cmd payload]
    (send! (lookup :url (read-ref chain))
           [(list cmd (sign-entity! payload))])))

(def create-issue!
  "Create a new remote issue with the keys in `my-keys.rad`."
  (fn [chain i]
    (send-signed-command! chain 'create-issue i)))

(def add-comment!
  "Create a remote comment with the keys in `my-keys.rad`."
  (fn [chain c]
    (send-signed-command! chain 'add-comment c)))

(def edit-issue!
  "Edit a remote issue with the keys in `my-keys.rad`."
  (fn [chain i]
    (send-signed-command! chain 'edit-issue i)))

(def edit-comment!
  "Edit a remote comment with the keys in `my-keys.rad`."
  (fn [chain c]
    (send-signed-command! chain 'edit-comment c)))

(def simple-create-issue!
  "Create a remote issue with sensible defaults."
  (fn [chain tit bod]
    (create-issue! chain (simple-issue {:title tit :body bod}))))

(def simple-add-comment!
  "Create a remote comment."
  (fn [chain in b]
    (add-comment! chain (simple-comment in b))))

(def simple-edit-issue!
  (fn [chain n i]
    (edit-issue! chain
                 (<> {:issue-number n
                      :modified-at (now!)}
                     i))))

(def simple-edit-comment!
  (fn [chain n i c]
    (edit-comment! chain
                   (<> {:issue-number n
                        :comment-index i
                        :modified-at (now!)}
                       c))))

(def list-issues
  "Return the full map of issues."
  (fn [chain]
    (lookup :result (chain/eval-in-chain '(list-issues) (read-ref chain)))))

(def fetch!
  "Update the locally cached state of the chain."
  (fn [chain]
    (chain/update-chain-ref! chain)))

(def import-github
  "Imports the github issues stored in file `githubissues.rad`. To create this
  file use the `radicle-github-issues` executable. Will add a note to all
  `:body`s that this is an imported entity."
  (fn [chain]
    (def note-imported
      (fn [x]
        (insert
         :body
         (string-append
          (lookup :body x)
          "\n\n*Imported from GitHub.* Original author: `"
          (lookup :github-username x)
          "`.")
         x)))
    (def note-comments
      (fn [i] (over (@ :comments) (fn [cs] (map note-imported cs)) i)))
    (def issues (read-file-value! "githubissues.rad"))
    (def imported
      (map
       (fn [i] (insert :modified-at (lookup :created-at i) (note-imported (note-comments i))))
       issues))
    (map (fn [i] (create-issue! chain i)) imported)))

(def short
  "Short render of an issue."
  (fn [i]
    (string-append
     (show (lookup :number i))
     ": "
     (lookup :title i))))

(def list-last
  "Get the last `n` issues."
  (fn [chain n]
    (def is (sort-by (fn [i] (- 0 (lookup :number i))) (values (list-issues chain))))
    (take n is)))

(def recent-activity
  "Returns the activity on the chain since a timestamp."
  (fn [chain from]
    (def mod-at
      (fn [x]
        (unix-epoch
         (lookup :modified-at x))))
    (def u (unix-epoch from))
    (def since
      (fn [xs]
        (filter (fn [x] (< u (mod-at x))) xs)))
    (def most-recent-first
      (fn [xs]
        (sort-by (fn [x] (- 0 (mod-at x)))
                 xs)))
    (def all-issues (values (list-issues chain)))
    (def is (map (fn [i]
                   {:activity    :new-issue
                    :modified-at (lookup :modified-at i)
                    :issue       i})
                 (since all-issues)))
    (def cs
      (cat-maybes
       (map (fn [i]
              (def xs (most-recent-first (since (lookup :comments i))))
              (if (eq? xs [])
                :nothing
                [:just
                 {:activity    :new-comments
                  :modified-at (lookup :modified-at (first xs))
                  :issue       i}]))
            all-issues)))
    (most-recent-first (<> is cs))))

(:test
 "The monadic issues chain works."
 [:setup
  (do (def chain-name "http://localhost:8000/chains/fxoo")
      (def chain (ref (chain/new-chain chain-name)))
      (create-issues-chain! chain-name)
      (simple-create-issue! chain "title0" "body0")
      (simple-create-issue! chain "title1" "body1")
      (simple-add-comment! chain 0 "comment0")
      (simple-add-comment! chain 1 "comment1")
      (simple-edit-issue! chain 0 {:state :closed})
      (simple-edit-comment! chain 0 0 {:body "comment0-edit"})
      (def t (now!))
      (simple-create-issue! chain "new" "new")
      (simple-create-issue! chain "newer" "newer")
      (simple-add-comment! chain 0 "new")
      (fetch! chain)
      (def is (list-issues chain))
      (def new (recent-activity chain t)))]
 [ (length (seq is)) ==> 4 ]
 [ (view (.. (@ 0) (@ :title)) is) ==> "title0" ]
 [ (view (.. (@ 1) (@ :title)) is) ==> "title1" ]
 [ (view (... [(@ 1) (@ :comments) (@nth 0) (@ :body)]) is) ==> "comment1" ]
 [ (view (... [(@ 0) (@ :comments) (@nth 0) (@ :body)]) is) ==> "comment0-edit" ]
 [ (short (first (values is))) ==> "0: title0" ]
 [ (short (first (list-last chain 1))) ==> "3: newer" ]
 [ (view (.. (@ 0) (@ :state)) is) ==> :closed ]
 [ (length new) ==> 3 ]
 [ (view (.. (@nth 0) (@ :activity)) new) ==> :new-comments ]
 [ (view (... [(@nth 1) (@ :issue) (@ :title)]) new) ==> "newer" ]
)
