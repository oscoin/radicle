;; Helpers for setting up and interacting with issues machine (as defined in
;; rad/monadic/issues-remote.rad)

;; Create a remote issue machine. Returns a ref for the machine that you
;; can assign to a variable.

(import prelude/lens :unqualified)
(import prelude/machine '[send-code! ]:unqualified)
(import prelude/time '[install-fake-clock] :unqualified)
(import prelude/io :as 'io)

(def radicle-issues-machine-id
  "The name of this machine."
  "monadic/radicle/issues")

(def create-issues-machine!
  "Create a remote issue machine with the given url."
  (fn [url]
    (machine/send-prelude! url)
    (send-code! url "rad/monadic/issue-remote.rad")))

(def sign-entity!
  "Assumes a key pair is stored at `my-keys.rad`. Using that key pair, will sign a
  dict by adding `:author` and `:signature` fields, so that it is valid
  according to `validator/signed`, while also adding a `:nonce`."
  (fn [e]
    (def nonce (uuid!))
    (def e_ (<> e {:machine-id radicle-issues-machine-id
                   :nonce    nonce}))
    (def ks (read-file-value! "my-keys.rad"))
    (def sig
      (gen-signature! (lookup :private-key ks)
                      (show e_)))
    (<> e_
        {:author    (lookup :public-key ks)
         :signature sig})))

(def simple-issue
  "Create an open issue with no comments or labels."
  (fn [i]
    (def t (now!))
    (<> {:labels      []
         :state       :open
         :comments    []
         :created-at  t
         :modified-at t}
        i)))

(def simple-comment
  "Create a comment for an issue."
  (fn [issue-number bod]
    (def t (now!))
    {:body         bod
     :issue-number issue-number
     :created-at   t
     :modified-at  t}))

(def send-signed-command!
  "Send a command signed by the keys in `my-keys.rad`."
  (fn [machine cmd payload]
    (machine/send!
      (lookup :url (read-ref machine))
      [(list cmd (sign-entity! payload))])))

(def create-issue!
  "Create a new remote issue with the keys in `my-keys.rad`."
  (fn [machine i]
    (send-signed-command! machine 'create-issue i)))

(def add-comment!
  "Create a remote comment with the keys in `my-keys.rad`."
  (fn [machine c]
    (send-signed-command! machine 'add-comment c)))

(def edit-issue!
  "Edit a remote issue with the keys in `my-keys.rad`."
  (fn [machine i]
    (send-signed-command! machine 'edit-issue i)))

(def edit-comment!
  "Edit a remote comment with the keys in `my-keys.rad`."
  (fn [machine c]
    (send-signed-command! machine 'edit-comment c)))

(def simple-create-issue!
  "Create a remote issue with sensible defaults."
  (fn [machine tit bod]
    (create-issue! machine (simple-issue {:title tit :body bod}))))

(def simple-add-comment!
  "Create a remote comment."
  (fn [machine in b]
    (add-comment! machine (simple-comment in b))))

(def simple-edit-issue!
  (fn [machine n i]
    (edit-issue! machine
                 (<> {:issue-number n
                      :modified-at (now!)}
                     i))))

(def simple-edit-comment!
  (fn [machine n i c]
    (edit-comment! machine
                   (<> {:issue-number n
                        :comment-index i
                        :modified-at (now!)}
                       c))))

(def list-issues
  "Return the full map of issues."
  (fn [machine]
    (lookup :result (machine/eval-in-machine '(list-issues) (read-ref machine)))))

(def fetch!
  "Update the locally cached state of the machine."
  (fn [machine]
    (machine/update-machine-ref! machine)))

(def import-github
  "Imports the github issues stored in file `githubissues.rad`. To create this
  file use the `radicle-github-issues` executable. Will add a note to all
  `:body`s that this is an imported entity."
  (fn [machine]
    (def note-imported
      (fn [x]
        (insert
         :body
         (string-append
          (lookup :body x)
          "\n\n*Imported from GitHub.* Original author: `"
          (lookup :github-username x)
          "`.")
         x)))
    (def note-comments
      (fn [i] (over (@ :comments) (fn [cs] (map note-imported cs)) i)))
    (def issues (read-file-value! "githubissues.rad"))
    (def imported
      (map
       (fn [i] (insert :modified-at (lookup :created-at i) (note-imported (note-comments i))))
       issues))
    (map (fn [i] (create-issue! machine i)) imported)))

(def short
  "Short render of an issue."
  (fn [i]
    (string-append
     (show (lookup :number i))
     ": "
     (lookup :title i))))

(def list-last
  "Get the last `n` issues."
  (fn [machine n]
    (def is (sort-by (fn [i] (- 0 (lookup :number i))) (values (list-issues machine))))
    (take n is)))

(def recent-activity
  "Returns the activity on the machine since a timestamp."
  (fn [machine from]
    (def mod-at
      (fn [x]
        (unix-epoch
         (lookup :modified-at x))))
    (def u (unix-epoch from))
    (def since
      (fn [xs]
        (filter (fn [x] (< u (mod-at x))) xs)))
    (def most-recent-first
      (fn [xs]
        (sort-by (fn [x] (- 0 (mod-at x)))
                 xs)))
    (def all-issues (values (list-issues machine)))
    (def is (map (fn [i]
                   {:activity    :new-issue
                    :modified-at (lookup :modified-at i)
                    :issue       i})
                 (since all-issues)))
    (def cs
      (cat-maybes
       (map (fn [i]
              (def xs (most-recent-first (since (lookup :comments i))))
              (if (eq? xs [])
                :nothing
                [:just
                 {:activity    :new-comments
                  :modified-at (lookup :modified-at (first xs))
                  :issue       i}]))
            all-issues)))
    (most-recent-first (<> is cs))))

(:test
 "The monadic issues machine works."
 [:setup
  (do (machine/install-remote-machine-fake)
      (install-fake-clock)
      (io/install-fake-filesystem!
        { "my-keys.rad" (show (gen-key-pair! (default-ecc-curve)))
        })
      (def machine-name (string-append "http://foo"))
      (def machine (ref (machine/new-machine machine-name)))
      (create-issues-machine! machine-name)
      (simple-create-issue! machine "title0" "body0")
      (simple-create-issue! machine "title1" "body1")
      (simple-add-comment! machine 0 "comment0")
      (simple-add-comment! machine 1 "comment1")
      (simple-edit-issue! machine 0 {:state :closed})
      (simple-edit-comment! machine 0 0 {:body "comment0-edit"})
      (def last-checked-at (now!))
      (simple-create-issue! machine "new" "new")
      (simple-create-issue! machine "newer" "newer")
      (simple-add-comment! machine 0 "new")
      (fetch! machine)
      (def is (list-issues machine))
      (def new (recent-activity machine last-checked-at)))]
 [ (length (seq is)) ==> 4 ]
 [ (view (.. (@ 0) (@ :title)) is) ==> "title0" ]
 [ (view (.. (@ 1) (@ :title)) is) ==> "title1" ]
 [ (view (... [(@ 1) (@ :comments) (@nth 0) (@ :body)]) is) ==> "comment1" ]
 [ (view (... [(@ 0) (@ :comments) (@nth 0) (@ :body)]) is) ==> "comment0-edit" ]
 [ (short (first (values is))) ==> "0: title0" ]
 [ (short (first (list-last machine 1))) ==> "3: newer" ]
 [ (view (.. (@ 0) (@ :state)) is) ==> :closed ]
 [ (length new) ==> 3 ]
 [ (view (.. (@nth 0) (@ :activity)) new) ==> :new-comments ]
 [ (view (... [(@nth 1) (@ :issue) (@ :title)]) new) ==> "newer" ]
)
