;; Helpers for setting up and interacting with issues chain (as defined in
;; rad/monadic/issues-remote.rad)

;; Create a remote issue chain. Returns a ref for the chain that you
;; can assign to a variable.

(load! "rad/prelude.rad")

(import prelude/lens :unqualified)

(def radicle-issues-chain-id
  "The name of this chain."
  "monadic/radicle/issues")

(def issues-chain
  (ref (chain/load-chain! "http://localhost:8000/chains/radicle-issues")))

(def create-issues-chain!
  "Create a remote issue chain with the given url."
  (fn [url]
    (chain/send-prelude! url)
    (send-code! url "rad/monadic/issue-remote.rad")))

(def sign-entity!
  "Assumes a key pair is stored at `my-keys.rad`. Using that key pair, will sign a
  dict by adding `:author` and `:signature` fields, so that it is valid
  according to `validator/signed`, while also adding a `:nonce`."
  (fn [e]
    (def nonce (uuid!))
    (def e_ (<> e {:chain-id radicle-issues-chain-id
                   :nonce    nonce}))
    (def ks (read-file-value! "my-keys.rad"))
    (def sig
      (gen-signature! (lookup :private-key ks)
                      (show e_)))
    (<> e_
        {:author    (lookup :public-key ks)
         :signature sig})))

(def simple-issue
  "Create an open issue with no comments or labels."
  (fn [tit bod]
    (def t (now!))
    {:title       tit
     :body        bod
     :labels      []
     :state       :open
     :comments    []
     :created-at  t
     :modified-at t}))

(def simple-comment
  "Create a comment for an issue."
  (fn [issue-number bod]
    (def t (now!))
    {:body         bod
     :issue-number issue-number
     :created-at   t
     :modified-at  t}))

(def send-signed-command!
  "Send a command signed by the keys in `my-keys.rad`."
  (fn [chain cmd payload]
    (send! (lookup :url (read-ref chain))
           [(list cmd (sign-entity! payload))])))

(def create-issue!
  "Create a new remote issue with the keys in `my-keys.rad`."
  (fn [chain i]
    (send-signed-command! chain 'create-issue i)))

(def add-comment!
  "Create a remote comment with the keys in `my-keys.rad`."
  (fn [chain c]
    (send-signed-command! chain 'add-comment c)))

(def edit-issue!
  "Edit a remote issue with the keys in `my-keys.rad`."
  (fn [chain i]
    (send-signed-command! chain 'edit-issue i)))

(def edit-comment!
  "Edit a remote comment with the keys in `my-keys.rad`."
  (fn [chain c]
    (send-signed-command! chain 'edit-comment c)))

(def simple-create-issue!
  "Create a remote issue with sensible defaults."
  (fn [chain tit bod]
    (create-issue! chain (simple-issue tit bod))))

(def simple-add-comment!
  "Create a remote comment."
  (fn [chain in b]
    (add-comment! chain (simple-comment in b))))

(def simple-edit-issue!
  (fn [chain n i]
    (edit-issue! chain
                 (<> {:issue-number n
                      :modified-at (now!)}
                     i))))

(def simple-edit-comment!
  (fn [chain n i c]
    (edit-comment! chain
                   (<> {:issue-number n
                        :comment-index i
                        :modified-at (now!)}
                       c))))

(def list-issues
  "Return the full map of issues."
  (fn [chain]
    (lookup :result (chain/eval-in-chain '(list-issues) (read-ref chain)))))

(def fetch!
  "Update the locally cached state of the chain."
  (fn [chain]
    (chain/update-chain-ref! chain)))

(def import-github
  "Imports the github issues stored in file `githubissues.rad`. To create this
  file use the `radicle-github-issues` executable. Will add a note to all
  `:body`s that this is an imported entity."
  (fn [chain]
    (def note-imported
      (fn [x]
        (insert
         :body
         (string-append
          (lookup :body x)
          "\n\n*Imported from GitHub.* Original author: `"
          (lookup :github-username x)
          "`.")
         x)))
    (def note-comments
      (fn [i] (over (@ :comments) (fn [cs] (map note-imported cs)) i)))
    (def issues (read-file-value! "githubissues.rad"))
    (def imported
      (map
       (fn [i] (note-imported (note-comments i)))
       issues))
    (map (fn [i] (create-issue! chain i)) imported)))

(def short
  "Short render of an issue."
  (fn [i]
    (string-append
     (show (lookup :number i))
     ": "
     (lookup :title i))))

(def list-last
  "Get the last `n` issues."
  (fn [chain n]
    (def is (sort-by (fn [i] (- 0 (lookup :number i))) (values (list-issues chain))))
    (take n is)))

(def get-by-id
  (fn [chain id]
    (lookup id (list-issues chain))))

(:test
 "The monadic issues chain works."
 [:setup
  (do (def chain-name "http://localhost:8024/chains/fxoo")
      (def chain (ref (chain/new-chain chain-name)))
      (create-issues-chain! chain-name)
      (simple-create-issue! chain "title0" "body0")
      (simple-create-issue! chain "title1" "body1")
      (simple-add-comment! chain 0 "comment0")
      (simple-add-comment! chain 1 "comment1")
      (simple-edit-issue! chain 0 {:state :closed})
      (simple-edit-comment! chain 0 0 {:body "comment0-edit"})
      (fetch! chain)
      (def is (list-issues chain)))]
 [ (length (seq is)) ==> 2 ]
 [ (view (.. (@ 0) (@ :title)) is) ==> "title0" ]
 [ (view (.. (@ 1) (@ :title)) is) ==> "title1" ]
 [ (view (... [(@ 1) (@ :comments) (@nth 0) (@ :body)]) is) ==> "comment1" ]
 [ (view (... [(@ 0) (@ :comments) (@nth 0) (@ :body)]) is) ==> "comment0-edit" ]
 [ (short (first (values is))) ==> "0: title0" ]
 [ (short (first (list-last chain 1))) ==> "1: title1" ]
 [ (view (.. (@ 0) (@ :state)) is) ==> :closed ]
)
