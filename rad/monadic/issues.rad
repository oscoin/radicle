;; Helpers for setting up and interacting with issues chain (as defined in
;; rad/monadic/issues-remote.rad)

;; Create a remote issue chain. Returns a ref for the chain that you
;; can assign to a variable.

(def radicle-issues-chain-id
  "The name of this chain."
  "monadic/radicle/issues")

(def issues-chain
  (ref (load-chain "http://radicle.xyz/chains/radicle-issues")))

(def create-issues-chain!
  "Create a remote issue chain with the given url."
  (fn []
    (def url (lookup :url (read-ref issues-chain)))
    (send-prelude! url)
    (send-code! url "rad/chains/issue-remote.rad")))

(def sign-entity!
  "Assumes a key pair is stored at `my-keys.rad`. Using that key pair, will sign
  an entity (a dict) by adding `:author` and `:signature` fields, so that it is
  valid according to `validator/signed`."
  (fn [e]
    (def ks (read (read-file! "my-keys.rad")))
    (def sig (gen-signature! (lookup :private-key ks) (show (insert :chain-id radicle-issues-chain-id e))))
    (<> e
        {:author    (lookup :public-key ks)
         :signature sig
         :chain-id  radicle-issues-chain-id})))

(def simple-issue
  (fn [tit bod]
    {:title    tit
     :body     bod
     :labels   []
     :state    :open
     :comments []
     :created-at (now!)}))

(def create-issue!
  "Create a new remote issue. Signs the issue and all it's comments with the key
  stored `my-keys.rad`."
  (fn [i]
    (def issue-id (uuid!))
    (def comment-entities
      (map (fn [c]
             (sign-entity! (<> c {:id (uuid!)
                                  :issue-id issue-id})))
           (lookup :comments i)))
    (def e
      (sign-entity!
       (<> i {:id issue-id
              :comments comment-entities})))
    (send! (lookup :url (read-ref issues-chain))
           [(list 'create-issue e)])
    ))

(def simple-create-issue!
 (fn [tit bod]
   (create-issue! (simple-issue tit bod))))

(def list-issues
  "Given an issues ref `x`, returns its issues. Does not itself update the chain."
  (fn []
    (update-chain-ref issues-chain)
    (lookup :result (eval-in-chain '(list-issues) (read-ref issues-chain)))))

(def import-github
  (fn []
    (def note-imported
      (fn [x]
        (insert
         :body
         (string-append
          (lookup :body x)
          "\n\n*Imported from GitHub.* Original author: `"
          (lookup :github-username x)
          "`.")
         x)))
    (def note-comments
      (fn [i] (over (@ :comments) (fn [cs] (map note-imported cs)) i)))
    (def issues (read (read-file! "githubissues.rad")))
    (def imported
      (map
       (fn [i] (note-imported (note-comments i)))
       issues))
    (map create-issue! imported)
    ))

(:test
  "creating, manipulating and querying issue chains"
  [:setup
     (do
       (def pk (gen-key-pair! (default-ecc-curve)))
       (def chain-name (uuid!))
       (def chain-ref (create-issues-chain! chain-name))
       (new-issue! chain-ref pk "Ah!" "if thou issueless shall hap to die")
       (update-chain-ref chain-ref)
       (def issues (values (list-issues chain-ref))))
   ]
   [ (length issues) ==> 1 ]
   [ (lookup :title (nth 0 issues)) ==> "Ah!" ]
   [ (lookup :body (nth 0 issues)) ==> "if thou issueless shall hap to die" ]
)
