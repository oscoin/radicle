;; Issue chain
;; Meant to be sent to a chain with send-code!

(def chain-id
  "The name of this chain."
  "monadic/radicle/issues")

(def issues
  "Issues are stored in a dict in a ref."
  (ref {}))

(def issue-counter (lookup :next (make-counter)))

(def used-ids
  "We keep track of the UUIDs which have been used in the chain."
  (ref set/empty))

(def id-free?
  "Check that an ID has not been used yet."
  (fn [id]
    (not (set/member? id (read-ref used-ids)))))

(def mark-used-id
  "Mark a UUID as used."
  (fn [id]
    (modify-ref used-ids (fn [s] (set/insert id s)))))

(def set-issues
  "A helper to set stuff in the issues ref."
  (fn [l v]
    (set-ref issues l v)))

(def over-issues
  "A helper to modify stuff in the issues ref."
  (fn [l f]
    (over-ref issues l f)))

(def validator/free-uuid
  "Given a predicate which says if an ID is free, checks input is a free UUID."
  (validator/and
   [validator/uuid
    (validator/pred "ID is free" id-free?)]))

(def validator/text
  (fn [max-len]
    (validator/and
     [(validator/type :string)
      (validator/pred (string-append "< " (show max-len) " chars in length")
                      (fn [s] (< (string-length s) max-len)))])))

;; TODO correctly formatted date string
(def validator/timestamp
  (validator/type :string))

(def validator/entity
  "Checks that the input as a valid new *chain entity*, that is, it has an unused
  UUID, is marked with this chain name, and is signed."
  (validator/and
   [(validator/keys
     {:id         validator/free-uuid
      :chain-id   (validator/= chain-id)
      ;; NOTE that the timestamp is claimed by the author, is not verified, and
      ;; may be incorrect.
      :created-at validator/timestamp})
    validator/signed]))

(def strip-entity
  "After an entity has been saved to the chain, we no longer need to keep the
  chain-id or the signature, since this has already been checked."
  (fn [e]
    (delete-many [:chain-id :signature] e)))

(def validator/comment
  "Checks a comment is a chain entity which refers to an issue and has a text
  body."
  (validator/and
   [validator/entity
    (validator/keys
     {:issue-id validator/uuid
      :body     (validator/text 4000)})]))

(def validator/issue
  "Checks an issue a chain entity with a title, body, etc."
  (validator/and
   [validator/entity
    (validator/keys
     {:title      (validator/text 100)
      :body       (validator/text 4000)
      :labels     (validator/every (validator/text 80))
      :state      (validator/member [:open :closed])
      :comments   (validator/every validator/comment)})]))

(def strip-comment
  (fn [c]
    (delete :issue-id (strip-entity c))))

(def create-issue
  "Create an issue from a dict, checking it is valid and storing it in `issues`."
  (fn [i]
    (def id (lookup :id i))
    (validator/issue i)
    (def i_
      (strip-entity
       (<> i
           {:number (issue-counter)
            :comments (map strip-comment (lookup :comments i))})))
    (set-issues (@ id) i_)
    (mark-used-id id)))

(def close-issue
  "Set the state of an issue to `:closed`."
  (fn [id]
    (set-issues (.. (@ id) (@ :state)) :closed)))

(def add-comment
  "Add a comment to an issue."
  (fn [c]
    (def id (lookup :id c))
    (validator/comment c)
    (mod-issues (.. (@ id) (@ :comments)) (fn [cs] (add-right (strip-comment c) cs)))
    (mark-used-id id)))

;; These are intended for clients to run locally with eval-in-chain

(def list-issues
  "List existing issues."
  (fn [] (read-ref issues)))

;; General logic

(def commands
  "The set of allowed chain commands."
  (ref
   {'create-issue create-issue
    'close-issue  close-issue
    'add-comment  add-comment
    'list-issues  list-issues}))

(def process-command
  "Function that maps post-eval commands to existing functions"
  (fn [expr]
    (def command (head expr))
    (def args    (tail expr))
    (def do-this (lookup command (read-ref commands)))
    (apply do-this args)))

;; Move to eval-fn-app & updatable-eval from chain.rad to a pure file so it may
;; be imported

(def eval-fn-app
  "Given a state, a function, an argument and a callback, returns
  the result of evaluating the function call on the arg in the given
  state, while also calling the callback on the result."
  (fn [state f arg cb]
    (def exec (base-eval (list f (list 'quote arg)) state))
    (cb (head exec))
    exec))

(def updatable-eval
  "Given an evaluation function `f`, returns a new one which augments `f` with a new
  command `(update expr)` which evaluates arbitrary expression using `base-eval`."
  (fn [sub-eval]
    (fn [expr state]
      (list-with-head
       expr
       (fn [cmd]
         (if (eq? cmd 'update)
           (base-eval (nth 1 expr) state)
           (sub-eval expr state)))
       (fn [] (sub-eval expr state))))))

(def eval (updatable-eval
    (fn [expr state]
      (eval-fn-app state 'process-command expr (fn [x] x)))))
