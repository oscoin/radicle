#!/usr/bin/env radicle

(load! "rad/prelude.rad")
(load! "rad/monadic/issues.rad")
(load! "rad/prelude/io-utils.rad")

(def base-name "http://machines.radicle.xyz/chains/")

(def name-base "http://machines.radicle.xyz/chains/names")

(def help
  (string-append
  "rad-issues - Radicle issue CLI

   Usage:
        rad-issues [list|new|create-chain] <chain-name>
        rad-issues make-key <nick>
        rad-issues names
        rad-issues help

     list         - Select from all issues to view or comment on
     new          - Create a new issue in $EDITOR
     create-chain - Create a new issues chain
     make-key     - Create a key-pair and register the name
     names        - See all registered names
     help         - Print this help and exit

   If <chain-name> begins with 'http://', that URL will be used. Otherwise,
  " base-name " will be prepended to <chain-name>." ))

(def make-name
  (fn [chain]
    (if (eq? (take 7 chain) "http://")
        chain
        (string-append base-name chain))))

(def make-chain-ref
  (fn [chain]
    (ref (chain/load-chain! (make-name chain)))))

(def mark-last-seen
  (fn []
    (write-persistent-key! :radicle-issues/last-seen (now!))))

(def comment-divider "---")

(def add-comment-md
  (fn [x]
    (string-append
     "\n" comment-divider "\n"
     "---Add comment above the line.\n\n"
     x)))

(def pretty-comment
  "Markdown view of a comment. Assumes that the comment has been annotated with a
  username."
  (fn [c]
    (match c
      '{:username u-n
        :created-at c-a
        :body b}
      (string-append "### " u-n " [" c-a "]\n\n" b "\n"))))

(def pretty-issue
  "Markdown view of an issue. Assumes the issue and comments have been annotated
  with usernames."
  (fn [i]
    (match i
      '{:number n
        :title tit
        :body b
        :state state
        :labels ls
        :comments cs}
      (string-replace
       "\r"
       ""
       (string-append
        "# Issue " (show n) ": " tit "\n\n"
        "**State:** " (if (eq? state :open) "open" "closed") "\n"
        "**Labels:** " (show ls) "\n\n"
        b "\n\n"
        "Comments\n"
        "--------\n\n"
        (string/unlines (map pretty-comment cs)))))))

(def list-items
  "Lists the recent items and uses an editor to add a relevant comment."
  (fn [chain last-seen]

    (def chain-ref (make-chain-ref chain))
    (load! "rad/monadic/names.rad")
    (def names (ref (chain/load-chain! name-base)))
    (def add-username
      (fn [d]
        (def n (catch
                   'any
                   (lookup :github-username d)
                 (fn [x]
                   (match (lookup-key names (lookup :author d))
                          :nothing "???"
                          'name    name))))
        (insert :username n d)))

    (def add-username-issue
      (fn [i]
        (add-username
         (insert :comments (map add-username (lookup :comments i)) i))))

    (def mk-key
      (fn [v]
        (match v
               (/as 'a {:activity :new-issue
                        :issue    {:number 'n
                                   :title 'tit}})
               [(string-append "[new] Issue " (show n) " - " tit) a]
               (/as 'a {:activity :new-comments
                        :issue    {:number 'n
                                   :title 'tit}})
               [(string-append "[new comments] Issue " (show n) " - " tit) a])))

    (def items (map mk-key (recent-activity chain-ref last-seen)))

    (match (fzf-select! (map first items))
           (/just 's)
           (do (def selected (lookup s (dict-from-seq items)))
               (def issue-number (match selected {:issue {:number 'n}} n))
               (def pretty-item
                 (add-comment-md
                  (pretty-issue
                   (add-username-issue
                    (lookup :issue selected)))))
               (def edited-item (edit-in-editor! pretty-item))
               (def added-comment
                 (string/unlines
                  (take-while (fn [x] (not (eq? x comment-divider)))
                              (string/lines edited-item))))
               (put-str!
                (if (eq? added-comment "")
                  "Item was not updated."
                  (do (simple-add-comment! chain-ref issue-number added-comment)
                      (string-append "Sent comment: " added-comment)))))
           _ (print! "No selection made."))))

(def new-issue
  (fn [chain]
    (def chain-ref (make-chain-ref chain))
    (def template
";; Issue template. An empty or invalid value will abort.
{:title      \"Pick a title\"
 :body       \"Pick a body\"
 :labels     []
}
")
    (def i (read (edit-in-editor! template)))
    (create-issue!
         chain-ref (simple-issue i))))

(def create-chain
  (fn [chain]
    (create-issues-chain! (make-name chain))))

(def make-key
  (fn [name]
    (def kp (gen-key-pair! (default-ecc-curve)))
    (write-file! "my-keys.rad" (show kp))
    (load! "rad/monadic/names.rad")
    (add-name! name-base name (lookup :public-key kp))))

(def names
  (fn []
    (load! "rad/monadic/names.rad")
    (print! (list-names name-base))))

(def args (get-args!))
(match args
  ["list" "new" 'chain]   (list-items chain (read-persistent-key! :radicle-issues/last-seen))
  ["list" 'chain]         (list-items chain :nothing)
  ["names"]               (names)
  ["make-key" 'name]      (make-key name)
  ["new"  'chain]         (new-issue chain)
  ["create-chain" 'chain] (create-chain chain)
  ["done"]                (mark-last-seen)
  ["help"]                (put-str! help)
  _                       (do
                            (put-str! (string-append "Unrecognized command" (show args)))
                            (put-str! help)))
