#!/usr/bin/env radicle

(load! (find-module-file! "prelude.rad"))
(load! (find-module-file! "monadic/issues.rad"))
(load! (find-module-file! "monadic/project.rad"))
(load! (find-module-file! "prelude/io-utils.rad"))

(import prelude/validation :as 'validation)
(import prelude/machine :as 'machine)
(import prelude/cmd-parsing :unqualified)

(def machine-name (fn [] (get-rsm-of-type! :rad-issues)))

(def help
  "rad-issues - Radicle issue CLI

   Usage:
        rad-issues list [--closed] [--open]
        rad-issues new
        rad-issues close <issue-number>
        rad-issues make-key <nick>
        rad-issues create-machine
        rad-issues help

     list         - Select from issues to view or comment on
     new          - Create a new issue in $EDITOR
     close        - Close an issue
     help         - Print this help and exit
   ")

(def cmd-parse-failure
  (fn [error]
    (parse-failure error help)))

(def comment-divider "---")

(def add-comment-md
  (fn [x]
    (string-append
     "\n" comment-divider "\n"
     "---Add comment above the line.\n\n"
     x)))

(def pretty-comment
  "Markdown view of a comment. Assumes that the comment has been annotated with a
  username."
  (fn [c]
    (match c
      '{:username u-n
        :created-at c-a
        :body b}
      (string-append "### " u-n " [" c-a "]\n\n" b "\n"))))

(def pretty-issue
  "Markdown view of an issue. Assumes the issue and comments have been annotated
  with usernames."
  (fn [i]
    (match i
      '{:number n
        :title tit
        :body b
        :state state
        :labels ls
        :comments cs
        :username un
        :created-at c-a}
      (string-replace
       "\r"
       ""
       (string-append
        "# Issue " (show n) ": " tit "\n\n"
        "created by " un " [" c-a "]\n\n"
        "**State:** " (if (eq? state :open) "open" "closed") "\n"
        "**Labels:** " (show ls) "\n\n"
        b "\n\n"
        "Comments\n"
        "--------\n\n"
        (string/unlines (map pretty-comment cs)))))))

(def list-items
  "Lists the recent items and uses an editor to add a relevant comment."
  (fn [machine options]

    (def add-username
      (fn [d]
        (def n (catch
                   'any
                   (lookup :github-username d)
                   (fn [_] "???")))
        (insert :username n d)))

    (def add-username-issue
      (fn [i]
        (add-username
         (insert :comments (map add-username (lookup :comments i)) i))))

    (def mk-key
      (fn [v]
        (match v
          (/as 'i {:issue {:number 'n :title 'tit}})
            [(string-append "Issue " (show n) " - " tit) i])))

    (def filt
      (match [(lookup-default "open" #f options)
              (lookup-default "closed" #f options)]
             [#t #f] (fn [x] (eq? (lookup :state (lookup :issue x)) :open))
             [#f #t] (fn [x] (eq? (lookup :state (lookup :issue x)) :closed))
             _       (fn [x] #t)))

    (def items
      (map mk-key
        (filter filt
          (map (fn [i] {:issue i}) (reverse (values (list-issues machine)))))))

    (def items-dict (dict-from-seq items))
    (if (empty-seq? items)
      (put-str! "No issues!")
      (match (fzf-select-with-preview!
               (map first items)
               (fn [s] (pretty-issue (add-username-issue (lookup :issue (lookup s items-dict))))))
             (/just 's)
             (do (def selected (lookup s items-dict))
                 (def issue-number (match selected {:issue {:number 'n}} n))
                 (def pretty-item
                   (add-comment-md
                    (pretty-issue
                     (add-username-issue
                      (lookup :issue selected)))))
                 (def edited-item (edit-in-editor! pretty-item))
                 (def added-comment
                   (string/unlines
                    (take-while (fn [x] (not (eq? x comment-divider)))
                                (string/lines edited-item))))
                 (put-str!
                  (if (eq? added-comment "")
                    "Item was not updated."
                    (do (simple-add-comment! machine issue-number added-comment)
                        (string-append "Sent comment: " added-comment)))))
             _ (put-str! "No selection made.")))))

(def close-issue
  (fn [issue-number machine-name]
    (def n (read issue-number))
    (if (number? n)
      (if (integral? n)
        (simple-edit-issue! machine n {:state :closed})
        (cmd-parse-failure "Issue numbers must be whole numbers!"))
      (cmd-parse-failure "To close an issue, please provide the issue number."))))

(def new-issue
  (fn [machine]
    (def template
";; Issue template. An empty or invalid value will abort.
{:title      \"Pick a title\"
 :body       \"Pick a body\"
 :labels     []
}
")
    (def i (read (edit-in-editor! template)))
    (create-issue!  machine (simple-issue i))))

(def valid-list-options
  ["--open" "--closed"])

(def list-options
  (fn [os]
    (foldr (fn [o acc]
             (if (member? o valid-list-options)
               (insert (drop 2 o) #t acc)
               (cmd-parse-failure (string-append "Invalid list option: " o))))
           {}
           os)))

(def /list-cmd
  (fn [opts]
    (/cmd-1-opts "list" opts list-options)))

(def args (get-args!))
(match args
  (/list-cmd 'options) (list-items (machine-name) options)
  (/cmd-1 "make-key" 'nick help) (make-key nick)
  (/cmd-0 "new" help) (new-issue (machine-name))
  (/cmd-1 "create-machine" 'machine-name help) (create-machine machine-name)
  (/cmd-1 "close" 'issue-number help) (close-issue issue-number (machine-name))
  ["help"] (put-str! help)
  ["-h"] (put-str! help)
  ["--help"] (put-str! help)
  (/cons 'cmd _) (cmd-parse-failure (string-append "Unknown command: " cmd))
  [] (put-str! help))
