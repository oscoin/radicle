#!/usr/bin/env radicle

(load! "rad/prelude.rad")
(load! "rad/monadic/issues.rad")
(load! "rad/prelude/io-utils.rad")

(import prelude/validation :as 'validation)

(def base-name "http://machines.radicle.xyz/chains/")

(def name-base "http://machines.radicle.xyz/chains/names")

(def help
  (string-append
  "rad-issues - Radicle issue CLI

   Usage:
        rad-issues [list|list-new|new|create-chain] <chain-name>
        rad-issues make-key <nick>
        rad-issues names
        rad-issues help

     list         - Select from all issues to view or comment on
     list-new     - Select from all issues that have new activity
     done         - Mark all issues as 'seen'
     new          - Create a new issue in $EDITOR
     create-chain - Create a new issues chain
     make-key     - Create a key-pair and register the name
     names        - See all registered names
     help         - Print this help and exit

   If <chain-name> begins with 'http://', that URL will be used. Otherwise,
  " base-name " will be prepended to <chain-name>." ))

(def make-name
  (fn [chain]
    (if (eq? (take 7 chain) "http://")
        chain
        (string-append base-name chain))))

(def make-chain-ref
  (fn [chain]
    (ref (chain/load-chain! (make-name chain)))))

(def mark-last-seen
  (fn []
    (write-file-key! ".radicle-issues" :last-mark-done (now!))))

(def comment-divider "---")

(def add-comment-md
  (fn [x]
    (string-append
     "\n" comment-divider "\n"
     "---Add comment above the line.\n\n"
     x)))

(def pretty-comment
  "Markdown view of a comment. Assumes that the comment has been annotated with a
  username."
  (fn [c]
    (match c
      '{:username u-n
        :created-at c-a
        :body b}
      (string-append "### " u-n " [" c-a "]\n\n" b "\n"))))

(def pretty-issue
  "Markdown view of an issue. Assumes the issue and comments have been annotated
  with usernames."
  (fn [i]
    (match i
      '{:number n
        :title tit
        :body b
        :state state
        :labels ls
        :comments cs
        :username un
        :created-at c-a}
      (string-replace
       "\r"
       ""
       (string-append
        "# Issue " (show n) ": " tit "\n\n"
        "created by " un " [" c-a "]\n\n"
        "**State:** " (if (eq? state :open) "open" "closed") "\n"
        "**Labels:** " (show ls) "\n\n"
        b "\n\n"
        "Comments\n"
        "--------\n\n"
        (string/unlines (map pretty-comment cs)))))))

(def list-items
  "Lists the recent items and uses an editor to add a relevant comment."
  (fn [chain last-seen]

    (def chain-ref (make-chain-ref chain))
    (load! "rad/monadic/names.rad")
    (def names (ref (chain/load-chain! name-base)))
    (def add-username
      (fn [d]
        (def n (catch
                   'any
                   (lookup :github-username d)
                 (fn [x]
                   (match (lookup-key names (lookup :author d))
                          :nothing "???"
                          'name    name))))
        (insert :username n d)))

    (def add-username-issue
      (fn [i]
        (add-username
         (insert :comments (map add-username (lookup :comments i)) i))))

    (def mk-key
      (fn [v]
        (match v
               (/as 'a {:activity :new-issue
                        :issue    {:number 'n
                                   :title 'tit}})
               [(string-append "[new] Issue " (show n) " - " tit) a]
               (/as 'a {:activity :new-comments
                        :issue    {:number 'n
                                   :title 'tit}})
               [(string-append "[new comments] Issue " (show n) " - " tit) a]
               (/as 'i {:issue {:number 'n :title 'tit}})
               [(string-append "Issue " (show n) " - " tit) i])))

    (def items
      (map mk-key
           (match last-seen
             (/just 't) (recent-activity chain-ref t)
             _          (map (fn [i] {:issue i})
                             (values (list-issues chain-ref))))))

    (if (empty-seq? items)
      (put-str! "No recent items!")
      (match (fzf-select! (map first items))
             (/just 's)
             (do (def selected (lookup s (dict-from-seq items)))
                 (def issue-number (match selected {:issue {:number 'n}} n))
                 (def pretty-item
                   (add-comment-md
                    (pretty-issue
                     (add-username-issue
                      (lookup :issue selected)))))
                 (def edited-item (edit-in-editor! pretty-item))
                 (def added-comment
                   (string/unlines
                    (take-while (fn [x] (not (eq? x comment-divider)))
                                (string/lines edited-item))))
                 (put-str!
                  (if (eq? added-comment "")
                    "Item was not updated."
                    (do (simple-add-comment! chain-ref issue-number added-comment)
                        (string-append "Sent comment: " added-comment)))))
             _ (put-str! "No selection made.")))))

(def new-issue
  (fn [chain]
    (def chain-ref (make-chain-ref chain))
    (def template
";; Issue template. An empty or invalid value will abort.
{:title      \"Pick a title\"
 :body       \"Pick a body\"
 :labels     []
}
")
    (def i (read (edit-in-editor! template)))
    (create-issue!
         chain-ref (simple-issue i))))

(def create-chain
  (fn [chain]
    (create-issues-chain! (make-name chain))))

(def make-key
  (fn [name]
    (def kp (gen-key-pair! (default-ecc-curve)))
    (write-file! "my-keys.rad" (show kp))
    (load! "rad/monadic/names.rad")
    (add-name! name-base name (lookup :public-key kp))))

(def names
  (fn []
    (load! "rad/monadic/names.rad")
    (print! (list-names name-base))))

(init-file-dict! ".radicle-issues")

(def cmd-parse-failure
  (fn [error]
    (put-str! error)
    (put-str! help)
    (exit! 1)
  ))

(def /cmd-1
  (fn [cmd cmd-args-pat]
    ((validation/type :string) cmd)
    ((validation/type :atom) cmd-args-pat)
    (fn [value]
      (match value
        [cmd 'cmd-args] (match-pat cmd-args-pat cmd-args)
        [cmd] (cmd-parse-failure (string-append "Missing argument \"" (show cmd-args-pat) "\" for command \"" cmd "\""))
        (/cons cmd _) (cmd-parse-failure (string-append "Too many arguments for command \"" cmd "\""))
        _ :nothing)
    )))

(def /cmd-0
  (fn [cmd]
    ((validation/type :string) cmd)
    (fn [value]
      (match value
        [cmd] [:just {}]
        (/cons cmd _) (cmd-parse-failure (string-append "Too many arguments for command \"" cmd "\""))
        _ :nothing)
    )))

(def args (get-args!))
(match args
  (/cmd-1 "list" 'chain-name) (list-items chain-name :nothing)
  (/cmd-1 "list-new" 'chain-name) (list-items chain-name (read-file-key! ".radicle-issues" :last-mark-done))
  (/cmd-0 "names") (names)
  (/cmd-1 "make-key" 'nick) (make-key nick)
  (/cmd-1 "new" 'chain-name) (new-issue 'chain-name)
  (/cmd-1 "create-chain" 'chain-name) (create-chain 'chain-name)
  (/cmd-0 "done") (mark-last-seen)
  ["help"] (put-str! help)
  ["-h"] (put-str! help)
  ["--help"] (put-str! help)
  (/cons 'cmd _) (cmd-parse-failure (string-append "Unknown command: " cmd))
  [] (put-str! help))
